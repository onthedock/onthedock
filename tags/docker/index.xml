<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on On The Dock</title>
    <link>http://192.168.1.9:8000/tags/docker/index.xml</link>
    <description>Recent content in Docker on On The Dock</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <atom:link href="http://192.168.1.9:8000/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Portainer para monitorizar tus contenedores en Docker</title>
      <link>http://192.168.1.9:8000/post/170429-portainer-para-monitorizar-tus-contenedores-en-docker/</link>
      <pubDate>Sat, 29 Apr 2017 12:55:04 +0200</pubDate>
      
      <guid>http://192.168.1.9:8000/post/170429-portainer-para-monitorizar-tus-contenedores-en-docker/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://portainer.io/&#34;&gt;Portainer&lt;/a&gt; es una herramienta ligera y &lt;em&gt;open-source&lt;/em&gt; de gestión de contenedores sobre Docker (o Docker Swarm). Portainer ofrece una interfaz gráfica para gestionar el &lt;em&gt;host&lt;/em&gt; Docker desde cualquier navegador, tiene soporte para Raspberry Pi y se puede desplegar como un simple contenedor.&lt;/p&gt;

&lt;p&gt;Espero que este artículo ayude a todos aquellos que tengan ganas de probar Portainer y evitarles los problemas que me he encontrado yo.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;He estado buscando algún tipo de solución gráfica para monitorizar las Raspberry Pi ya que, por algún motivo, los nodos &lt;em&gt;worker&lt;/em&gt; del clúster de Kubernetes se &lt;em&gt;cuelgan&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Buscando alguna solución de monitorizado he encontrado Portainer referenciado en el blog de Hypriot: &lt;a href=&#34;https://blog.hypriot.com/post/new-docker-ui-portainer/&#34;&gt;Visualize your Raspberry Pi containers with Portainer or UI for Docker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Portainer no es una herramienta de monitorizado (a nivel de &lt;em&gt;host&lt;/em&gt;), sino que está enfocada a la &lt;em&gt;visualización&lt;/em&gt; básicamente del estado de los contenedores de uno (o varios) &lt;em&gt;endpoints&lt;/em&gt; Docker (o Docker Swarm). Sin embargo, ofreciendo soporte para ARM y estando disponible en forma de contenedor, no había motivo para no probarlo ;)&lt;/p&gt;

&lt;h1 id=&#34;soporte-para-arm&#34;&gt;Soporte para ARM&lt;/h1&gt;

&lt;p&gt;En el apartado para obtener Portainer de la web, sólo se indica el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d -p 9000:9000 portainer/portainer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por muy minimalista que quiera ser la página, la verdad es que no les hubiera costado nada indicar que existen diferentes versiones disponibles de la imagen (como por ejemplo, la que proporciona soporte para ARM).&lt;/p&gt;

&lt;p&gt;Además, lanzando el comando &lt;em&gt;tal cual&lt;/em&gt;, si quieres configurar Portainer para monitorizar el nodo &lt;em&gt;local&lt;/em&gt;, &lt;strong&gt;no funcionará&lt;/strong&gt; (requiere montar &lt;code&gt;/var/run/docker.sock&lt;/code&gt; en el contenedor).&lt;/p&gt;

&lt;p&gt;El artículo de Hypriot apunta a una imagen llamada &lt;code&gt;portainer/portainer:arm&lt;/code&gt;, que ya no existe en DockerHub. Revisando las &lt;a href=&#34;https://hub.docker.com/r/portainer/portainer/tags/&#34;&gt;etiquetas disponibles para las imágenes de Portainer&lt;/a&gt;, encontramos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;TagName				Compressed Size 	Last Updated 
ppc64le				4 MB			16 days ago
demo				4 MB			23 days ago
latest				0 B 			23 days ago
1.12.4				0 B 			23 days ago
windows-amd64 			337 MB			23 days ago
windows-amd64-1.12.4	 	337 MB			23 days ago
linux-arm64 			4 MB			23 days ago
linux-arm64-1.12.4 		4 MB			23 days ago
linux-arm 			4 MB			23 days ago
linux-arm-1.12.4 		4 MB			23 days ago
linux-amd64 			4 MB			23 days ago
linux-amd64-1.12.4 		4 MB			23 days ago
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seleccionamos la versión adecuada para nuestra Raspberry Pi y la descargamos mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker pull portainer/portainer:linux-arm-1.12.4
linux-arm-1.12.4: Pulling from portainer/portainer
a3ed95caeb02: Pull complete
802d894958a2: Pull complete
30fb5c96d238: Pull complete
Digest: sha256:5269fd824014fac1dee29e2cf74aa5c337cf5c0ceb7cae2634c1e054f5e2763f
Status: Downloaded newer image for portainer/portainer:linux-arm-1.12.4
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación he lanzado la creación del contenedor usando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -d -p 9000:9000 --name portainer portainer/portainer:linux-arm-1.12.4
d5ad5764788a932cd19942dcb0e70471101173c8d14801b0ce7c172ef9ac72ff
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;acceso-a-portainer&#34;&gt;Acceso a Portainer&lt;/h2&gt;

&lt;p&gt;Abre un navegador y accede a &lt;code&gt;http://IP-nodo:9000/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;La primera vez que accedes a la URL de Portainer debes introducir el password del usuario &lt;code&gt;admin&lt;/code&gt;.&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;http://192.168.1.9:8000/images/170429/portainer-1-define-admin-password.png&#34; alt=&#34;Portainer para monitorizar tus contenedores en Docker images/170429/portainer-1-define-admin-password.png&#34; width=640 height=400 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;p&gt;Una vez introducido, puedes acceder a la UI de gestión de Portainer.&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;http://192.168.1.9:8000/images/170429/portainer-2-first-login.png&#34; alt=&#34;Portainer para monitorizar tus contenedores en Docker images/170429/portainer-2-first-login.png&#34; width=640 height=400 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;p&gt;Para mostrar información sobre los contendores (imágenes, volúmenes, etc) en Docker, Portainer necesita conectarse -vía API- al &lt;em&gt;host&lt;/em&gt; en el que corre Docker. Tenemos dos opciones, un &lt;em&gt;endpoint remoto&lt;/em&gt; (opción por defecto) o conectar con el &lt;em&gt;host&lt;/em&gt; donde corre Portainer:&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;http://192.168.1.9:8000/images/170429/portainer-3-remote_endpoint_by_default.png&#34; alt=&#34;Portainer para monitorizar tus contenedores en Docker images/170429/portainer-3-remote_endpoint_by_default.png&#34; width=640 height=400 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;p&gt;El problema es que, como vemos, al seleccionar un &lt;em&gt;endpoint&lt;/em&gt; local, se indica que hay que lanzar el contenedor de Portainer dando acceso al contenedor sobre &lt;code&gt;/var/run/docker.sock&lt;/code&gt;:&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;http://192.168.1.9:8000/images/170429/portainer-4-local_endpoint_require_docker.sock.png&#34; alt=&#34;Portainer para monitorizar tus contenedores en Docker images/170429/portainer-4-local_endpoint_require_docker.sock.png&#34; width=640 height=400 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;p&gt;Como este &lt;em&gt;detalle&lt;/em&gt; no se indica en ningún sitio hasta que estás intentando configurar Portainer, lo más probable es que no hayas lanzado el contenedor con el volumen necesario.&lt;/p&gt;

&lt;p&gt;Así que es necesario detener el contenedor -y eliminarlo, si quieres reusar el nombre- y volver a lanzar el proceso de configuración.&lt;/p&gt;

&lt;p&gt;No son más que unos pocos comandos en Linux (o en tu Mac), pero sin duda es una molestia que podría evitarse dando algo más de información. Mucho más grave es si el sistema operativo de tu &lt;em&gt;host&lt;/em&gt; es Windows, ya que &lt;strong&gt;esta opción no está disponible&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker stop portainer
portainer
$ docker rm portainer
portainer
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;acceso-a-portainer-segundo-intento&#34;&gt;Acceso a Portainer (segundo intento)&lt;/h2&gt;

&lt;p&gt;Lanzamos el contenedor de Portainer montando &lt;code&gt;docker.sock&lt;/code&gt; y pasamos por los mismos pasos que en intento anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -d -p 9000:9000 --name portainer -v &amp;quot;/var/run/docker.sock:/var/run/docker.sock&amp;quot; portainer/portainer:linux-arm-1.12.4
3f0ad98393ed5c67cda864737d83fe098a13d1317e1f6c299419ab1a3c1d153c
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Después de validarnos, podemos conectar con el &lt;em&gt;docker-engine&lt;/em&gt; local y visualizar el &lt;em&gt;dashboard&lt;/em&gt;:&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;http://192.168.1.9:8000/images/170429/portainer-5-dashboard.png&#34; alt=&#34;Portainer para monitorizar tus contenedores en Docker images/170429/portainer-5-dashboard.png&#34; width=640 height=400 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;p&gt;Desde la interfaz web podemos gestionar los contenedores, imágenes y volúmenes existentes:&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;http://192.168.1.9:8000/images/170429/portainer-6-containers.png&#34; alt=&#34;Portainer para monitorizar tus contenedores en Docker images/170429/portainer-6-containers.png&#34; width=640 height=400 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
  &lt;figcaption&gt;
    
    Contenedores.
    
  &lt;/figcaption&gt;
  
&lt;/figure&gt;


&lt;figure&gt;
  &lt;amp-img src=&#34;http://192.168.1.9:8000/images/170429/portainer-7-images.png&#34; alt=&#34;Portainer para monitorizar tus contenedores en Docker images/170429/portainer-7-images.png&#34; width=640 height=400 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
  &lt;figcaption&gt;
    
    Imágenes.
    
  &lt;/figcaption&gt;
  
&lt;/figure&gt;


&lt;figure&gt;
  &lt;amp-img src=&#34;http://192.168.1.9:8000/images/170429/portainer-8-volumes.png&#34; alt=&#34;Portainer para monitorizar tus contenedores en Docker images/170429/portainer-8-volumes.png&#34; width=640 height=400 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
  &lt;figcaption&gt;
    
    Volúmenes.
    
  &lt;/figcaption&gt;
  
&lt;/figure&gt;


&lt;p&gt;En el próximo artículo me concentraré en usar &lt;a href=&#34;http://192.168.1.9:8000/tags/portainer/&#34;&gt;Portainer&lt;/a&gt; para realizar la gestión de Docker.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Instala Docker en Ubuntu Server 16.04</title>
      <link>http://192.168.1.9:8000/post/170110-instala-docker-en-ubuntu-server-16.04/</link>
      <pubDate>Tue, 10 Jan 2017 15:12:46 +0100</pubDate>
      
      <guid>http://192.168.1.9:8000/post/170110-instala-docker-en-ubuntu-server-16.04/</guid>
      <description>&lt;p&gt;Cómo instalar Docker en Ubuntu Server 16.04.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Para instalar la última versión de Docker, usamos las instrucciones &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/como-instalar-y-usar-docker-en-ubuntu-16-04-es&#34;&gt;¿Cómo instalar y usar Docker en Ubuntu 16.04?&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;No funciona por algún motivo, probablemente por el &lt;em&gt;proxy&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Para instalar la clave GPG de Docker, el método que funciona es (&lt;small&gt;ref: &lt;a href=&#34;https://github.com/docker/docker/issues/17436#issuecomment-151870782&#34;&gt;Docker website encourages users to import GPG key for apt repository in unsafe ways #17436&lt;/a&gt;&lt;/small&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# curl -s  https://get.docker.com/gpg | apt-key add -
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agregamos el repositorio de Docker a APT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-add-repository &#39;deb https://apt.dockerproject.org/repo ubuntu-xenial main&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actualizamos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez añadido, comprobamos mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-cache policy docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finalmente, instalamos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install -y docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si ha habido problemas para validar la autenticidad del paquete de Docker, la instalación debe hacerse sin la aceptación automática (es decir, sin el parámetro &lt;code&gt;-y&lt;/code&gt;) o añadiendo &lt;code&gt;--allow-authenticate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Verificamos que tenemos docker funcionando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# docker version
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Introducción a Hypriot OS</title>
      <link>http://192.168.1.9:8000/post/161105-introduccion-a-hypriotos/</link>
      <pubDate>Sat, 05 Nov 2016 10:37:47 +0100</pubDate>
      
      <guid>http://192.168.1.9:8000/post/161105-introduccion-a-hypriotos/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.hypriot.com/about/#hypriotos:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;HypriotOS&lt;/a&gt; es un sistema operativo basado en &lt;a href=&#34;http://www.debian.org/&#34;&gt;Debian&lt;/a&gt; optimizado para ejecutar &lt;a href=&#34;http://www.docker.com/&#34;&gt;Docker&lt;/a&gt; en plataformas ARM como las &lt;a href=&#34;https://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;hypriotos&#34;&gt;HypriotOS&lt;/h1&gt;

&lt;p&gt;Las características principales de HypriotOs son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sistema operativo basado de Debian: la mayor parte de la gente saber cómo usar Debian y las distribuciones basadas en Ubuntu.&lt;/li&gt;
&lt;li&gt;Optimizado para Docker: Todo en HypriotOS está orientado a conseguir que Docker se ejecute de maravilla, desde las configuraciones del kernel de Linux hasta el sistema de ficheros.&lt;/li&gt;
&lt;li&gt;Versiones actualizadas de Docker: Hypriot se actualiza cada vez que se publica una nueva versión de Docker.&lt;/li&gt;
&lt;li&gt;Listo para usar: descargar, &lt;em&gt;flashear&lt;/em&gt; y arrancar, es lo único que hace falta para ponerse en marcha con HypriotOS.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;instalación-de-hypriotos&#34;&gt;Instalación de HypriotOS&lt;/h2&gt;

&lt;p&gt;La instalación de HypriotOS en la Raspberry Pi es muy sencilla.&lt;/p&gt;

&lt;p&gt;En el blog de Hypriot tienes información para grabar la imagen en una tarjeta SD tanto si usas &lt;a href=&#34;http://blog.hypriot.com/getting-started-with-docker-on-your-arm-device/&#34;&gt;Windows, Linux o Mac&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;En mi caso, he usado un equipo con Windows para pasar la imagen a la tarjeta SD siguiendo los siguientes pasos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Descarga la imagen con Hypriot en formato comprimido desde &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;sección de descargas del blog de Hypriot&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Descomprime el &lt;em&gt;zip&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Usa &lt;a href=&#34;http://sourceforge.net/projects/win32diskimager/&#34;&gt;Win32DiskImager&lt;/a&gt; para pasar la imagen descomprimida a la tarjeta SD.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;¡Eso es todo!&lt;/p&gt;

&lt;p&gt;El siguiente paso es colocar de nuevo la tarjeta SD en la Raspberry Pi y arrancar.&lt;/p&gt;

&lt;h2 id=&#34;obtener-la-dirección-ip-de-la-raspberry-pi&#34;&gt;Obtener la dirección IP de la Raspberry Pi&lt;/h2&gt;

&lt;p&gt;Por defecto, la Raspberry Pi con HypriotOS obtiene una dirección IP del DHCP local. En el blog de Hypriot recomiendan usar un programa para escanear tu red local y obtener la dirección asignada a la Raspberry Pi (&lt;a href=&#34;http://sourceforge.net/projects/nmap.mirror/?source=typ_redirect&#34;&gt;ZenMap&lt;/a&gt; o &lt;a href=&#34;http://angryip.org/download/#windows, en los comentarios&#34;&gt;Angry IP Scanner&lt;/a&gt;. En mi caso, he accedido a la lista de clientes a los cuales el DHCP les ha asignado una dirección IP y he obtenido la dirección asignada al equipo llamado &lt;em&gt;black-pearl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una vez obtenida la dirección IP, conéctate usando &lt;a href=&#34;http://the.earth.li/~sgtatham/putty/latest/x86/putty.exe&#34;&gt;&lt;em&gt;Putty&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Introduce la IP asignada a la Raspberry Pi en el campo &lt;em&gt;Host Name (or IP address)&lt;/em&gt; y verifica que el puerto es el 22.&lt;/p&gt;

&lt;p&gt;La primera vez que conectes a la dirección IP de la Raspberry Pi obtendrás un mensaje de aviso indicando si quieres confiar en el equipo.&lt;/p&gt;

&lt;p&gt;Puedes iniciar sesión en la Raspberry Pi usando el nombre de usuario &lt;code&gt;pirate&lt;/code&gt; y el password  &lt;code&gt;hypriot&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finalmente, para verificar que Docker se encuentra presente, ejecuta &lt;code&gt;docker info&lt;/code&gt;. La salida de este comando te devolverá las versiones de cliente y servidor instaladas.&lt;/p&gt;

&lt;h2 id=&#34;crea-tu-primer-contenedor&#34;&gt;Crea tu primer contenedor&lt;/h2&gt;

&lt;p&gt;Ya está todo listo para ejecutar tu primer contenedor. Y es tan sencillo como lanzar el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p 80:80 hypriot/rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este comando ejecuta un contendor (&lt;code&gt;docker run&lt;/code&gt;) en segundo plano, de forma no interactiva (&lt;code&gt;-d&lt;/code&gt;, &lt;em&gt;dettached&lt;/em&gt;), conectando el puerto 80 (web) de tu equipo local con el puerto 80 del contenedor. El contenedor se creará a partir de la imagen &lt;code&gt;hypriot/rpi-busybox-httpd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cuando Docker intenta crear el contenedor, busca la imagen indicada en su registro local. Si no lo encuentra, se conecta a un registro público -por defecto Docker Hub- y busca la imagen allí.&lt;/p&gt;

&lt;p&gt;Una vez localizada la imagen, descarga en el registro local una copia de la imagen y finalmente arranca un contenedor basado en esa imagen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p  80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
19d131999ea3142d44a83a6e943c9052d8defa43f7da372bd08ec441ee55f31b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La imagen descargada contiene &lt;code&gt;busybox&lt;/code&gt; y un servidor web minimalista. Puedes acceder al servidor arrancado en el contenedor a través de un navegador, indicando la IP de la Raspberry Pi.&lt;/p&gt;

&lt;h3 id=&#34;un-contenedor-más-útil&#34;&gt;Un contenedor más útil&lt;/h3&gt;

&lt;p&gt;Como ejemplo de primer contenedor y de lo fácil que es lanzar contenedores con Docker, el ejemplo anterior no está mal.&lt;/p&gt;

&lt;p&gt;Sin embargo, vamos a seguir los mismos pasos para crear un contenedor que proporciona un entorno web de gestión de Docker:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock hypriot/rpi-dockerui
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso observamos que, además de las instrucciones que hemos visto en el caso anterior, tenemos un nuevo parámetro &lt;code&gt;-v&lt;/code&gt;, que permite &lt;em&gt;montar&lt;/em&gt; una ruta local del equipo &lt;em&gt;host&lt;/em&gt; en el contenedor. Sin embargo, no te preocupes si ahora no entindes todos los detalles.&lt;/p&gt;

&lt;p&gt;Una vez arrancado el contenedor, accede a través de un navegador a &lt;code&gt;http://{IP-equipo-docker}:9000&lt;/code&gt;. Desde este entorno web puedes controlar el estado de tu instalación de Docker vía web gracias a &lt;a href=&#34;https://github.com/kevana/ui-for-docker&#34;&gt;UI-for-Docker&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;asigna-una-ip-estática&#34;&gt;Asigna una IP estática&lt;/h2&gt;

&lt;p&gt;En el apartado anterior hemos visto cómo instalar Docker y hemos lanzado los primeros contenedores. Pero la Raspberry Pi sigue con la configuración de la dirección IP dinámica, por lo que puede que la próxima vez que intentes acceder a la RPi, su dirección haya cambiado.&lt;/p&gt;

&lt;p&gt;Para evitar estos problemas, vamos a asignar la IP -estática- 192.168.1.51.&lt;/p&gt;

&lt;p&gt;Abrimos el fichero &lt;code&gt;/etc/network/interfaces&lt;/code&gt; y encontramos que se hace referencia a una carpeta de configuración:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;# interfaces(5) file used by ifup(8) and ifdown(8)
# Include files from /etc/network/interfaces.d:
source-directory /etc/network/interfaces.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abrimos el fichero de configuración de la tarjeta de red &lt;code&gt;eth0&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;allow-hotplug eth0
iface eth0 inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vemos que está configurada en modo &lt;code&gt;DHCP&lt;/code&gt;, por lo que comentamos la segunda línea y especificamos la configuración de IP estática:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;# iface eth0 inet dhcp

# Set static IP 
iface eth0 inet static
address 192.168.1.51
gateway 192.168.1.1
domain_name_servers=8.8.8.8, 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por supuesto, debes indicar la configuración de red de tu entorno.&lt;/p&gt;

&lt;p&gt;Guardamos los cambios y reiniciamos el servicio de red mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo $ sudo /etc/init.d/networking restart
[....] Restarting networking (via systemctl): networking.service
. ok
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Como la IP de la Raspberry Pi ha cambiado, la conexión remota desde tu equipo se perderá.&lt;/p&gt;

&lt;p&gt;Debes conectar de nuevo con la Raspberry Pi usando la IP que acabas de asignar.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;encontrando-tu-raspberry-pi-en-la-red-gracias-a-avahi&#34;&gt;Encontrando tu Raspberry Pi en la red gracias a Avahi&lt;/h3&gt;

&lt;p&gt;Desde la versión 0.3 &lt;em&gt;Jack&lt;/em&gt;, HypriotOS usa &lt;a href=&#34;https://en.wikipedia.org/wiki/Avahi_(software)&#34;&gt;Avahi&lt;/a&gt;, el sistema que permite a los programas publicar y descubrir servicios y hosts en una red local. De esta forma puedes acceder a los servicios publicados por los contenedores vía web (o hacer un ping) usando el nombre del sistema: &lt;strong&gt;&lt;code&gt;black-pearl&lt;/code&gt;&lt;/strong&gt; (por defecto).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;He comprobado que funciona desde un equipo Mac; falta comprobarlo desde un equipo Windows.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>