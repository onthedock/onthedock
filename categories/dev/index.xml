<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev on On The Dock</title>
    <link>https://onthedock.github.io/categories/dev/index.xml</link>
    <description>Recent content in Dev on On The Dock</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <atom:link href="https://onthedock.github.io/categories/dev/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Revisión de conceptos</title>
      <link>https://onthedock.github.io/post/170528-revision-de-conceptos/</link>
      <pubDate>Sun, 28 May 2017 07:59:31 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170528-revision-de-conceptos/</guid>
      <description>&lt;p&gt;Después de estabilizar el clúster, el siguiente paso es poner en marcha aplicaciones. Pero ¿qué es exactamente lo que hay que desplegar?: ¿&lt;em&gt;pods&lt;/em&gt;?, ¿&lt;em&gt;replication controllers&lt;/em&gt;?, ¿&lt;em&gt;deployments&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Muchos artículos empiezan creando el fichero YAML para un &lt;em&gt;pod&lt;/em&gt;, después construyen el &lt;em&gt;replication controller&lt;/em&gt;, etc&amp;hellip; Sin embargo, revisando la documentación oficial, crear &lt;em&gt;pods&lt;/em&gt; directamente en Kubernetes no tiene mucho sentido.&lt;/p&gt;

&lt;p&gt;En este artículo intento determinar qué objetos son los que deben crearse en un clúster Kubernetes.
&lt;/p&gt;

&lt;h2 id=&#34;pod&#34;&gt;Pod&lt;/h2&gt;

&lt;p&gt;La unidad fundamental de despliegue en Kubernetes es el &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/&#34;&gt;&lt;strong&gt;Pod&lt;/strong&gt;&lt;/a&gt;. Un &lt;em&gt;pod&lt;/em&gt; sería el equivalente a la mínima unidad funcional de la aplicación.&lt;/p&gt;

&lt;p&gt;En general, un &lt;em&gt;pod&lt;/em&gt; contendrá únicamente un contenedor, aunque no tiene que ser así: si tenemos dos contenedores que actúan de forma conjunta, podemos desplegarlos dentro de un solo &lt;em&gt;pod&lt;/em&gt;. Dentro de un &lt;em&gt;pod&lt;/em&gt; todos los contenedores se pueden comunicar entre ellos usando &lt;code&gt;localhost&lt;/code&gt;, por lo que es una manera sencilla de desplegar en Kubernetes aplicaciones que, aunque hayan sido &lt;em&gt;containerizadas&lt;/em&gt;, no puedan modificarse para comunicarse con otras partes de la aplicación usando una IP o un nombre DNS (porque la aplicación espera que el resto de &lt;em&gt;partes&lt;/em&gt; de la aplicación estén en el mismo equipo).&lt;/p&gt;

&lt;p&gt;En este sentido, todos los contenedores dentro de un &lt;em&gt;pod&lt;/em&gt; se podría decir que están instaladas en una mismo equipo (como un &lt;em&gt;stack&lt;/em&gt; LAMP).&lt;/p&gt;

&lt;p&gt;Sin embargo, un &lt;em&gt;pod&lt;/em&gt; es un elemento &lt;strong&gt;no-durable&lt;/strong&gt;, es decir, que puede fallar o ser eliminado en cualquier momento. Por tanto, &lt;strong&gt;no es una buena idea desplegar &lt;em&gt;pods&lt;/em&gt; individuales en Kubernetes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Como indica la &lt;a href=&#34;https://kubernetes.io/docs/api-reference/v1.6/#pod-v1-core&#34;&gt;documentación para los &lt;em&gt;pods&lt;/em&gt; de la API para la versión 1.6 de Kubernetes&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It is recommended that users create Pods only through a Controller, and not directly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;replicaset-y-replication-controller&#34;&gt;ReplicaSet y Replication Controller&lt;/h2&gt;

&lt;p&gt;El &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/&#34;&gt;&lt;strong&gt;Replication Controller&lt;/strong&gt;&lt;/a&gt; o la versión &lt;em&gt;mejorada&lt;/em&gt;, el &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/&#34;&gt;&lt;strong&gt;ReplicaSet&lt;/strong&gt;&lt;/a&gt; se encarga de mantener un determinado número de réplicas del &lt;em&gt;pod&lt;/em&gt; en el clúster.&lt;/p&gt;

&lt;p&gt;El &lt;em&gt;ReplicaSet&lt;/em&gt; asegura que un determinado número de copias -&lt;strong&gt;réplicas&lt;/strong&gt;- del &lt;em&gt;pod&lt;/em&gt; se encuentran en ejecución en el clúster en todo momento. Por tanto, si alguno de los &lt;em&gt;pods&lt;/em&gt; es eliminado, el &lt;em&gt;ReplicaSet&lt;/em&gt; se encarga de crear un nuevo &lt;em&gt;pod&lt;/em&gt;. Para ello, el &lt;em&gt;ReplicaSet&lt;/em&gt; incluye una plantilla con la que crear nuevos &lt;em&gt;pods&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Así, el &lt;em&gt;ReplicaSet&lt;/em&gt; define el &lt;strong&gt;estado deseado&lt;/strong&gt; de la aplicación: cuántas copias de mi aplicación quiero tener en todo momento en ejecución en el clúster.
Modificando el número de réplicas para el &lt;em&gt;ReplicaSet&lt;/em&gt; podemos &lt;strong&gt;escalar&lt;/strong&gt; (incrementar o reducir) el número de copias en ejecución en función de las necesidades.&lt;/p&gt;

&lt;p&gt;Por tanto, parece que el mejor candidato para ponerse a definir ficheros &lt;code&gt;YAML&lt;/code&gt; y desplegar aplicaciones en el clúster de Kubernetes sería un &lt;em&gt;ReplicaSet&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Si embargo, la &lt;a href=&#34;https://kubernetes.io/docs/api-reference/v1.6/#replicaset-v1beta1-extensions&#34;&gt;documentación oficial&lt;/a&gt; nos ofrece otra opción:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In many cases it is recommended to create a Deployment instead of ReplicaSet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Es decir, tenemos una opción mejor: el &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/&#34;&gt;&lt;strong&gt;Deployment&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;deployment&#34;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;El &lt;em&gt;Deployment&lt;/em&gt; añade la capacidad de poder actualizar la aplicación definida en un &lt;em&gt;ReplicaSet&lt;/em&gt; sin pérdida de servicio, mediante &lt;strong&gt;actualización continua&lt;/strong&gt; (&lt;em&gt;rolling update&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Si el estado deseado de la aplicación son tres réplicas de un pod basado en &lt;code&gt;yomismo/app-1.0&lt;/code&gt; y queremos actualizar a &lt;code&gt;yomismo/app-2.0&lt;/code&gt;, el &lt;em&gt;Deployment&lt;/em&gt; se encarga de realizar la transición de la versión 1.0 a la 2.0 de forma que no haya interrupción del servicio. La estrategia de actualización puede definirse manualmente, pero sin entrar en detalles, Kubernetes se encarga de ir eliminado progresivamente las réplicas de la aplicación v1.0 y sustituirlas por las de la v2.0.&lt;/p&gt;

&lt;p&gt;El proceso se hace de forma controlada, por lo que si surgen problemas con la nueva versión de la aplicación, la actualización se detiene y es posible realizar &lt;em&gt;marcha atrás&lt;/em&gt; hacia la versión estable.&lt;/p&gt;

&lt;h2 id=&#34;resumiendo&#34;&gt;Resumiendo&lt;/h2&gt;

&lt;p&gt;Así pues, después de leer la sección de &lt;a href=&#34;https://kubernetes.io/docs/concepts/&#34;&gt;Concepts&lt;/a&gt; de la documentación de Kubernetes, parece que ya tengo claro cuál es el proceso para desplegar aplicaciones en Kubernetes.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;En Docker

&lt;ol&gt;
&lt;li&gt;Crear fichero &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Construir imagen personalizada&lt;/li&gt;
&lt;li&gt;Subir imagen a un &lt;em&gt;Registry&lt;/em&gt; (de momento, DockerHub)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;En Kubernetes

&lt;ol&gt;
&lt;li&gt;Crear fichero &lt;code&gt;YAML&lt;/code&gt; definiendo el &lt;em&gt;Deployment&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Crear &lt;em&gt;Deployment&lt;/em&gt; en el clúster&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hay otros objetos específicos que pueden ser más adecuados para tus necesidades:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;DaemonSets&lt;/em&gt; : despliegan una copia de un &lt;em&gt;pod&lt;/em&gt; en cada nodo del clúster. Por ejemplo, un antivirus, o una herramienta de gestión de logs, etc&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Jobs&lt;/em&gt; y &lt;em&gt;CronJobs&lt;/em&gt;: crean &lt;em&gt;pods&lt;/em&gt; hasta asegurar que un número determinado finaliza con éxito, lo que completa el &lt;em&gt;job&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;StatefulSets&lt;/em&gt; : todavía en Beta, asignan una identidad única a los &lt;em&gt;pods&lt;/em&gt;, lo que garantiza que se creen o escalen en un orden determinado.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;siguientes-pasos&#34;&gt;Siguientes pasos&lt;/h2&gt;

&lt;p&gt;Al final de este proceso tendré una aplicación &lt;em&gt;simple&lt;/em&gt; desplegada en el clúster. Con &amp;ldquo;sencilla&amp;rdquo; quiero decir que las diferentes instancias de la aplicación actuan de forma independiente. Un ejemplo sería un servidor web: con el &lt;em&gt;deployment&lt;/em&gt; sería posible escalar la aplicación para dar respuesta a la demanda en todo momento y actualizar el contenido de la web sin interrupciones.&lt;/p&gt;

&lt;p&gt;El siguiente paso es crear una aplicación &lt;em&gt;compleja&lt;/em&gt; en la que tengamos, por ejemplo, un &lt;em&gt;frontend&lt;/em&gt; y un &lt;em&gt;backend&lt;/em&gt;. Para estas situaciones, necesitaremos definir un &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34;&gt;&lt;strong&gt;servicio&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introduccion a YAML</title>
      <link>https://onthedock.github.io/post/170525-introduccion-a-yaml/</link>
      <pubDate>Thu, 25 May 2017 18:34:11 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170525-introduccion-a-yaml/</guid>
      <description>&lt;p&gt;YAML es el lenguaje en el que se definen los &lt;em&gt;pods&lt;/em&gt;, los &lt;em&gt;deployments&lt;/em&gt; y demás estructuras en Kubernetes. Todos los artículos que he leído sobre cómo crear un fichero de definición del &lt;em&gt;pod&lt;/em&gt; (&lt;em&gt;deployment&lt;/em&gt;, etc) se centran en el &lt;strong&gt;contenido&lt;/strong&gt; del fichero.&lt;/p&gt;

&lt;p&gt;Pero en mi caso, echaba de menos una explicación de &lt;strong&gt;cómo&lt;/strong&gt; se crea el fichero, qué reglas se siguen a la hora de &lt;em&gt;describir&lt;/em&gt; la configuración en formato YAML.&lt;/p&gt;

&lt;p&gt;Afortunadamente el lenguaje YAML es muy sencillo y basta con conocer un par de estructuras para crear los ficheros de configuración de Kubernetes.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;YAML es un lenguaje de marcado muy simple, basado en ficheros de texto plano legible por los humanos. Este formato se utiliza dentro del mundillo del software para almacenar información de tipo configuración.&lt;/p&gt;

&lt;p&gt;YAML son las siglas de &lt;em&gt;Yet Another Markup Language&lt;/em&gt; (Otro lenguaje de marcado más) o &lt;em&gt;YAML Ain&amp;rsquo;t Markup Language&lt;/em&gt; (YAML no es un lenguaje de marcado), depende de a quién preguntes.&lt;/p&gt;

&lt;p&gt;Usar YAML para las definiciones de Kubernetes proporciona las siguientes ventajas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Conveniencia&lt;/strong&gt; No es necesario especificar todos los parámetros en la línea de comandos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mantenimiento&lt;/strong&gt; Los ficheros YAML puede ser gestionados por un sistema de control de versiones, de manera que se pueden registrar los cambios.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexibilidad&lt;/strong&gt; Es posible crear estructuras mucho más complejas usando YAML de lo que puede conseguirse desde la línea de comandos.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;YAML es un superconjunto de JSON, lo que significa que cualquier fichero JSON válido también es un fichero YAML válido.&lt;/p&gt;

&lt;p&gt;Como consejos generales a la hora de crear un fichero YAML:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Usa siempre la codificación UTF-8 para evitar errores.&lt;/li&gt;
&lt;li&gt;No uses &lt;strong&gt;nunca&lt;/strong&gt; tabulaciones&lt;/li&gt;
&lt;li&gt;Usa una fuente monoespaciada para visualizar/editar el contenido de los ficheros YAML.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sólo necesitas conocer dos tipos de estructuras en YAML:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Listas&lt;/li&gt;
&lt;li&gt;Mapas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A parte de los mapas y las listas, también te puede resultar útil saber que cualquier línea que comience con un &lt;code&gt;#&lt;/code&gt; se considera un comentario y es ignorada.&lt;/p&gt;

&lt;h2 id=&#34;mapas-yaml&#34;&gt;Mapas YAML&lt;/h2&gt;

&lt;p&gt;Los mapas te permiten asociar parejas de nombres y valores, lo que es conveniente cuando estás tratando con información relativa a configuraciones. Por ejemplo, puedes tener una configuración que empiece como:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;---
apiVersion: v1
kind: Pod
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La primera línea es un separador, y es opcional a no ser que trates de definir múltiples estructuras en un solo fichero. En el fichero puedes ver que tenemos dos valores, &lt;code&gt;v1&lt;/code&gt; y &lt;code&gt;Pod&lt;/code&gt;, asociados a dos claves, &lt;code&gt;apiVersion&lt;/code&gt; y &lt;code&gt;kind&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No es necesario que los valores estén entrecomillados (con comillas simples o dobles), excepto para asegurarte de que no se interpreta algún caracter especial con un significado diferente a su valor literal.&lt;/p&gt;

&lt;p&gt;Las parejas clave-valor contenidas en un mapa se almacenan sin orden, por lo que puedes especificarlas en el orden que quieras.&lt;/p&gt;

&lt;p&gt;El fichero YAML anterior es equivalente a:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;---
kind: Pod
apiVersion: v1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos anidar mapas dentro de mapas para crear estructuras más complejas, como:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;---
apiVersion: v1
kind: Pod
metadata:
   name: rss-site
   labels:
      app: web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso tenemos un mapa llamado &lt;code&gt;metadata&lt;/code&gt; que contiene otros dos mapas; el primero &lt;code&gt;name: rss-site&lt;/code&gt; y el segundo, &lt;code&gt;labels&lt;/code&gt;, contiene como valor otro mapa &lt;code&gt;app: web&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Puedes anidar tantos mapas dentro de mapas como quieras.&lt;/p&gt;

&lt;p&gt;Para indicar que un mapa está contenido en otro, se usa la indentación. En el ejemplo anterior hemos usado una indentación de 3 espacios, pero el número de espacios no importa, siempre que sea &lt;strong&gt;consistente&lt;/strong&gt; en el fichero. El procesador de YAML interpreta las claves y valores en la misma profundidad de indentación como al mismo nivel (por ejemplo, &lt;code&gt;name&lt;/code&gt; y &lt;code&gt;labels&lt;/code&gt;), mientras que si están indentadas, interpreta que están &lt;em&gt;contenidas&lt;/em&gt; unos en otros (como en el caso de &lt;code&gt;labels&lt;/code&gt; y &lt;code&gt;app: web&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&#34;listas-en-yaml&#34;&gt;Listas en YAML&lt;/h2&gt;

&lt;p&gt;Una lista, en YAML, es una secuencia de objetos, o lo que es lo mismo, una colección ordenada de valores. En este caso los valores no están asociados con una clave, sino con un índice posicional obtenido del orden en el que están especificados en la lista. Por ejemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;args
   - sleep
   - 1000
   - message
   - &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Puede haber cualquier número de elementos en una lista.&lt;/p&gt;

&lt;p&gt;Como en el caso de las parejas clave-valor, los elementos de una lista se encuentran indentados con el mismo número de espacios bajo el identificador (la clave) de la lista; cada elemento de la lista va precedido por un &lt;code&gt;-&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Del mismo modo que podemos anidar mapas en mapas, podemos anidar listas en listas, mapas en listas y cualquier combinación imaginable. Un ejemplo de mapas y listas anidados:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# Configuracion ficticia
spec:
   containers:
      - name: front-end
        image: nginx
        ports:
           - containerPort: 80
      - name: rss-reader
        image: xavi/rss-reader
        ports:
           - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En resumen, tenemos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mapas&lt;/strong&gt;, que son grupos no ordenados de parejas de clave y valor&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Listas&lt;/strong&gt;, que son colecciones ordenadas de elementos individuales&lt;/li&gt;
&lt;li&gt;Mapas de mapas&lt;/li&gt;
&lt;li&gt;Mapas de listas&lt;/li&gt;
&lt;li&gt;Listas de mapas&lt;/li&gt;
&lt;li&gt;Listas de listas&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Básicamente, cualquier estructura que puedas imaginar, se puede construir a partir de estos dos elementos.&lt;/p&gt;

&lt;p&gt;Con estos conocimientos básicos, espero que ahora te resulte mucho más sencillo interpretar los ficheros de configuración de &lt;em&gt;pods&lt;/em&gt;, &lt;em&gt;deployments&lt;/em&gt;, etc. Y no sólo en Kubernetes; las configuraciones en formato YAML son usadas por un montón de productos diferentes.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Vagrant: primeras impresiones</title>
      <link>https://onthedock.github.io/post/170521-vagrant-primeras-impresiones/</link>
      <pubDate>Sun, 21 May 2017 09:26:45 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170521-vagrant-primeras-impresiones/</guid>
      <description>&lt;p&gt;He estado probando &lt;a href=&#34;https://www.vagrantup.com&#34;&gt;Vagrant&lt;/a&gt; para automatizar la creación de máquinas virtuales en las que probar Docker, etc.&lt;/p&gt;

&lt;p&gt;En este artículo comento mis primeras impresiones con Vagrant.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;La &lt;em&gt;tagline&lt;/em&gt; de Vagrant es &lt;em&gt;Development Environments made easy&lt;/em&gt;. Atraido con la posibilidad de ser capaz de crear entornos de forma automática, instalé Vagrant. Tenía la sensación de que sería una especie de &lt;em&gt;Docker para máquinas virtuales&lt;/em&gt;: hay un repositorio público de &lt;em&gt;boxes&lt;/em&gt; llamado &lt;a href=&#34;https://atlas.hashicorp.com/boxes/search?&#34;&gt;Atlas&lt;/a&gt; y con unos comandos como &lt;code&gt;vagrant init&lt;/code&gt; y &lt;code&gt;vagrant up&lt;/code&gt; parece posible &lt;em&gt;levantar&lt;/em&gt; un conjunto de máquinas preconfiguradas y listas para trabajar.&lt;/p&gt;

&lt;p&gt;Pensaba que Vagrant trabajaba únicamente con VirtualBox, así que me alegré al ver que es posible trabajar con otros &lt;em&gt;providers&lt;/em&gt;, en particular al ver que soporta Hyper-V &lt;em&gt;out of the box&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Busqué una máquina con Ubuntu 16 LTS en Atlas filtrando por &lt;code&gt;provider hyperv&lt;/code&gt; y encontré &lt;a href=&#34;https://atlas.hashicorp.com/kmm/boxes/ubuntu-xenial64&#34;&gt;https://atlas.hashicorp.com/kmm/boxes/ubuntu-xenial64&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mediante &lt;code&gt;vagrant init kmm/ubuntu-xenial64&lt;/code&gt; se crea el Vagrantfile, que describe las configuración de la VM.&lt;/p&gt;

&lt;p&gt;Para arrancar la máquina es necesario especificar el &lt;em&gt;provider&lt;/em&gt;, ya que por defecto se asume VirtualBox: &lt;code&gt;vagrant up --provider hyperv&lt;/code&gt;. El comando debe ejecutarse con permisos de administrador (debido a una limitación de Hyper-V).&lt;/p&gt;

&lt;p&gt;Al lanzar el comando por primera vez, como no tengo una copia local de la &lt;em&gt;box&lt;/em&gt;, debe descargarse. A diferencia de los contenedores, el tamaño de la máquina virtual es considerable. Afortunadamente la velocidad de la conexión y el hecho de que sólo tengo que hacerlo una vez mitigan este primer inconveniente.&lt;/p&gt;

&lt;p&gt;El comando inicializa la máquina y la registra en Hyper-V con el nombre &lt;code&gt;ubuntu-xenial64&lt;/code&gt;, arranca la máquina y obtiene una IP del DHCP. También se crea una clave SSH para poder conectar a la máquina y se monta una carpeta compartida entre la máquina virtual y el &lt;em&gt;host&lt;/em&gt; local (en la carpeta desde donde se lanza el comando &lt;code&gt;vagrant up&lt;/code&gt;). La máquina virtual también se crea en esa carpeta.&lt;/p&gt;

&lt;h2 id=&#34;conectando-vía-ssh&#34;&gt;Conectando vía SSH&lt;/h2&gt;

&lt;p&gt;En la documentación se indica que para conectar a la VM, hay que usar el comando &lt;code&gt;vagrant ssh&lt;/code&gt;. En Windows no funciona porque no hay un cliente SSH instalado por defecto.&lt;/p&gt;

&lt;p&gt;En Windows lo habitual es usar PuTTY, pero resulta que la clave privada que se ha generado no es compatible y es necesario convertirla al formato &lt;code&gt;ppk&lt;/code&gt;, usando &lt;a href=&#34;https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html&#34;&gt;PuTTYgen&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Al no tener una contraseña, esto significa que si quiero conectar desde otro equipo (por ejemplo, desde el Mac), tengo que copiar la clave privada al equipo.&lt;/p&gt;

&lt;h2 id=&#34;nombre-de-la-máquina-virtual&#34;&gt;Nombre de la máquina virtual&lt;/h2&gt;

&lt;p&gt;Aunque en la documentación se indica que puede especificarse el nombre de la máquina virtual mediante la opción &lt;a href=&#34;https://www.vagrantup.com/docs/hyperv/configuration.html#vmname&#34;&gt;&lt;code&gt;vmname&lt;/code&gt;&lt;/a&gt;, en mi caso no ha funcionado.&lt;/p&gt;

&lt;h2 id=&#34;ip-de-la-máquina-virtual&#34;&gt;IP de la máquina virtual&lt;/h2&gt;

&lt;p&gt;Aunque la máquina virtual arranca con la IP configurada en modo DHCP, me gustaría especificar la IP de la máquina a crear. Buscando en Google he encontrado que la IP debería poder configurarse mediante el parámetro: &lt;code&gt;config.vm.network :public_network, ip: &amp;quot;192.168.1.30&amp;quot;&lt;/code&gt;, tal y como se indica en &lt;a href=&#34;https://serverfault.com/questions/418422/public-static-ip-for-vagrant-box&#34;&gt;Public static ip for vagrant box&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;De nuevo, por algún motivo, no ha funcionado, obteniendo siempre la IP vía DHCP.&lt;/p&gt;

&lt;p&gt;No soy el único al que le pasa, por lo que parece: &lt;a href=&#34;https://github.com/cogitatio/vagrant-hostsupdater/issues/132&#34;&gt;static IP not set correctly&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;instalación-de-docker&#34;&gt;Instalación de Docker&lt;/h2&gt;

&lt;p&gt;Al final del fichero &lt;code&gt;Vagrantfile&lt;/code&gt; hay un apartado sobre &lt;em&gt;provisioning&lt;/em&gt;, para poder instalar paquetes adicionales en la máquina virtual. En mi caso, estaba interesado en instalar Docker, por ejemplo.&lt;/p&gt;

&lt;p&gt;Aunque en la documentación se indica que se pueden lanzar los comandos &lt;em&gt;tal cual&lt;/em&gt;, de nuevo no ha funcionado como esperaba:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt-get update
apt-get install docker.io -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tras el primer fallo he modificado el fichero &lt;code&gt;Vagrantfile&lt;/code&gt; para que los comandos se lancen como &lt;code&gt;root&lt;/code&gt; (&lt;code&gt;sudo apt-get update&lt;/code&gt;), pero no sólo no he solucionado el problema, sino que además al intentar lanzar manualmente, conectado a la máquina virtual la instalación, obtenía un error indicando que el fichero estaba en uso.&lt;/p&gt;

&lt;h2 id=&#34;montaje-de-la-carpeta-compartida&#34;&gt;Montaje de la carpeta compartida&lt;/h2&gt;

&lt;p&gt;Inicialmente he pensado que sería una buena idea poder disponer de una carpeta &lt;em&gt;de intercambio&lt;/em&gt;. Después de tener que lanzar múltiples máquinas virtuales para las pruebas de cambiar el nombre de la máquina virtual, la configuración de la IP, etc, me he dado cuenta que la carpeta compartida no sólo no me aporta nada, sino que ralentiza el proceso; se solicita usuario y password para montar la carpeta, de manera que el script se detiene (aunque la máquina arranca en Hyper-V). Incluso después de terminar el proceso mediante &lt;code&gt;Ctrl+C&lt;/code&gt; he tenido problemas para seguir ejecutando otros comandos (&lt;code&gt;vagrant destroy&lt;/code&gt;). En este caso, Ruby -el lenguaje usado por Vagrant- seguía en memoria y ha sido necesario matarlo a través del adminstrador de tareas para poder seguir ejecutando comandos Vagrant.&lt;/p&gt;

&lt;h2 id=&#34;ubicación-de-la-máquina-virtual&#34;&gt;Ubicación de la máquina virtual&lt;/h2&gt;

&lt;p&gt;Otro problema que me he encontrado es que la máquina virtual se crea en la misma carpeta desde donde se lanza el fichero &lt;code&gt;Vagrantfile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;En Hyper-V se puede definir una ruta por defecto donde almacenar las máquinas virtuales, pero parece que Vagrant ignora esta configuración.&lt;/p&gt;

&lt;p&gt;En el equipo de laboratorio tengo dos discos, un SSD y un disco mecánico y he distribuido las máquinas virtuales según mis preferencias. Así que el hecho de que Vagrant cree las máquinas sin tener en cuenta la configuración del proveedor Hyper-V supone un problema que debería corregir, buscando en la configuración de Vagrant (si es que es posible modificar este comportamiento).&lt;/p&gt;

&lt;h2 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Mi objetivo es automatizar la creación de una nueva máquina virtual con Docker y/o Kubernetes instalado.&lt;/p&gt;

&lt;p&gt;Tengo dos máquinas virtuales exportadas con Docker y Kubernetes, respectivamente, por lo que Vagrant no aporta nada que no pueda hacer ahora mismo importando las máquinas en Hyper-V.&lt;/p&gt;

&lt;p&gt;Mediante un script en Powershell importo la máquina virtual en Hyper-V con el nombre especificado; no he conseguido hacer lo mismo en Vagrant.&lt;/p&gt;

&lt;p&gt;Personalmente prefiero crear un par de scripts con Powershell para conseguir especificar la IP, el nombre del host, etc que no tener que lidiar con el fichero de configuración de Vagrant.&lt;/p&gt;

&lt;p&gt;Después de importar la máquina o de crearla vía Vagrant, tengo que conectar igualmente a la VM para cambiar el &lt;code&gt;hostname&lt;/code&gt; y especificar una IP estática. Al usar la importación en Hyper-V ya tengo instalado Docker y/o Kubernetes, que en las máquinas creadas con Vagrant debo instalar manualmente.&lt;/p&gt;

&lt;p&gt;No tengo claro si los problemas que he encontrado con Vagrant se deben a mi desconocimiento del producto o a problemas de &lt;em&gt;concepto&lt;/em&gt;. Quizás es el hecho de usar un proveedor diferente al que se usa por defecto (Hyper-V vs VirtualBox) o al hecho de que el equipo donde se ejecutan las máquinas virtuales es diferente al equipo de &lt;em&gt;desarrollo&lt;/em&gt; (por el fichero &lt;code&gt;private_key&lt;/code&gt; para conectar vía SSH).&lt;/p&gt;

&lt;p&gt;En cualquier caso, Vagrant no se adapta a mis necesidades, creando fricción, por lo que seguiré buscando otras soluciones para automatizar la creación de las máquinas virtuales.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Normas para estructurar ficheros implicados en la creación de contenedores</title>
      <link>https://onthedock.github.io/post/170520-normas-para-estructurar-ficheros-implicados-en-la-creacion-de-contenedores/</link>
      <pubDate>Sat, 20 May 2017 19:59:44 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170520-normas-para-estructurar-ficheros-implicados-en-la-creacion-de-contenedores/</guid>
      <description>&lt;p&gt;El proceso desde la creación a la ejecución del contenedor se puede separar en varias fases:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Creación de la imagen (mediante la redacción de un fichero &lt;code&gt;Dockerfile&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Construcción de la imagen&lt;/li&gt;
&lt;li&gt;Ejecución del contenedores&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Para tener los diferentes ficheros implicados en el proceso organizados de forma homogénea, me he autoimpuesto las siguientes reglas a la hora de estructurar los repositorios.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h2&gt;

&lt;p&gt;El primero paso para ejecutar un contenedor es crear la imagen en la que está basado. Para ello debes crear un fichero &lt;code&gt;Dockerfile&lt;/code&gt; en el que se indica la imagen base usada y los diferentes pasos de instalación de paquetes, configuración de usuarios, volúmenes y puertos expuestos.&lt;/p&gt;

&lt;p&gt;En la creación de la imagen intervienen, además del fichero &lt;code&gt;Dockerfile&lt;/code&gt;, ficheros de configuración, etc que se copian a la imagen desde la carpeta donde se encuentra el fichero &lt;code&gt;Dockerfile&lt;/code&gt; (el llamado &lt;em&gt;contexto&lt;/em&gt;, ver &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/build/#options&#34;&gt;Documentación oficial de &lt;code&gt;docker build&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Para gestionar los cambios sobre estos ficheros, lo más sencillo es guardarlos en un repositorio y tener un registro de todos los cambios que se van introduciendo a lo largo del tiempo.&lt;/p&gt;

&lt;p&gt;Todos los ficheros relacionados con la &lt;em&gt;creación&lt;/em&gt; de la imagen se colocan en una carpeta llamada &lt;code&gt;build&lt;/code&gt;, con el &lt;code&gt;Dockerfile&lt;/code&gt; y los ficheros de configuración, etc, agrupados en sus correspondientes carpetas.&lt;/p&gt;

&lt;p&gt;En esta carpeta también se incluyen un fichero con instrucciones para la creación de la imagen (condiciones en las que reutilizar la cache, puntos a tener en cuenta, etc) y un &lt;em&gt;script&lt;/em&gt; para lanzar la creación de la imagen de forma siempre igual (quizás el script borra ficheros temporales o descargados en ejecuciones anteriores, por ejemplo).&lt;/p&gt;

&lt;h2 id=&#34;construcción-de-la-imagen&#34;&gt;Construcción de la imagen&lt;/h2&gt;

&lt;p&gt;Una vez creado el &lt;code&gt;Dockerfile&lt;/code&gt;, &lt;em&gt;construyes&lt;/em&gt; la imagen mediante &lt;code&gt;docker build&lt;/code&gt;. Aunque en general la construcción se realiza mediante un sólo comando de la forma &lt;code&gt;docker build -t {repositorio/etiqueta} .&lt;/code&gt;, puede ser interesante disponer de documentación con indicaciones sobre las reglas de etiquetado de la imagen definidas por la empresa o similar.&lt;/p&gt;

&lt;h2 id=&#34;ejecución-del-contenedor&#34;&gt;Ejecución del contenedor&lt;/h2&gt;

&lt;p&gt;Finalmente la creación de contenedores basados en la imagen se realiza mediante un comando &lt;code&gt;docker run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A la hora de ejecutar el contenedor la instrucción puede incluir el nombre del contenedor final, la relación entre puertos del &lt;em&gt;host&lt;/em&gt; y el contenedor, el montaje de volúmenes, etc. En algunos casos, el contenedor admite parámetros que se pasan al comando definido en la instrucción &lt;code&gt;CMD&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para evitar errores o simplemente para no teclear una y otra vez comandos larguísimos para ejecutar el contenedor, podemos crear un &lt;em&gt;script&lt;/em&gt; que lance el contenedor con los parámetros necesarios, así como documentación de la funcionalidad proporcionada por el contenedor, etc.&lt;/p&gt;

&lt;p&gt;Estos ficheros se guardan en el carpeta llamada &lt;code&gt;run&lt;/code&gt;; básicamente el comando para lanzar la creación del contenedor de forma homogénea y las instrucciones con información sobre el uso del contenedor, volúmenes, etc.&lt;/p&gt;

&lt;h2 id=&#34;carpetas&#34;&gt;Carpetas&lt;/h2&gt;

&lt;p&gt;Para estructurar todos los ficheros implicados en el proceso de creación de un contenedor he definido la siguiente estructura de carpetas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./nombre-contenedor/
 |
 ├─Readme.md
 ├─build/
 | ├─Dockerfile
 | ├─build.sh
 | ├─Build-Instructions.md
 | ├─{context-files}/
 | ├─...
 | ├─{context-files}/
 ├─run/
 | ├─run.sh
 | ├─Run-Instructions.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;motivación&#34;&gt;Motivación&lt;/h2&gt;

&lt;p&gt;No he encontrado ningún artículo sobre la organización de los ficheros implicados en el creación de imágenes o de los flujos de trabajo asociados a estos procesos. Tampoco sobre las normas a la hora de etiquetar las imágenes o si se realizan validaciones a la hora de obtener/subir imágenes de repositorios públicos.&lt;/p&gt;

&lt;p&gt;Incluso en una empresa en la que el proceso de desarrollo y operación de las aplicaciones gire alrededor del concepto &lt;em&gt;DevOp&lt;/em&gt;, puede haber otros implicados en el proceso &lt;em&gt;administrativo&lt;/em&gt; del ciclo de vida de la aplicación: decisiones estratégicas, a nivel de seguridad, de &lt;em&gt;compliance&lt;/em&gt; con leyes como la protección de datos, etc.&lt;/p&gt;

&lt;p&gt;En los artículos/conferencias lo habitual es explicar soluciones técnicas sin entrar nunca en estos procesos que relacionan IT con el resto de departamentos de la empresa.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Habilita el acceso remoto vía API a Docker</title>
      <link>https://onthedock.github.io/post/170506-habilita-el-acceso-remoto-via-api-a-docker/</link>
      <pubDate>Sat, 06 May 2017 15:23:36 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170506-habilita-el-acceso-remoto-via-api-a-docker/</guid>
      <description>&lt;p&gt;Portainer permite gestionar &lt;em&gt;endpoints&lt;/em&gt; remotos para Docker (y Docker Swarm) mediante el API REST de Docker Engine. El problema es que el API está desactivado por defecto.&lt;/p&gt;

&lt;p&gt;A continuación indico cómo activar y verificar el acceso remoto al API de Docker Engine.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Buscando en Google cómo habilitar el API remoto de Docker Engine probablemente encuentres el artículo
&lt;a href=&#34;https://www.ivankrizsan.se/2016/05/18/enabling-docker-remote-api-on-ubuntu-16-04/&#34;&gt;Enabling Docker Remote API on Ubuntu 16.04&lt;/a&gt;. Como bien dice en el párrafo inicial, no es fácil encontrar unas instrucciones claras sobre cómo configurar el API de principio a fin.&lt;/p&gt;

&lt;p&gt;Lanzando &lt;code&gt;docker man&lt;/code&gt;, vemos que la opción que buscamos es:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-H, --host=[unix:///var/run/docker.sock]: tcp://[host]:[port][path] to bind or
       unix://[/path/to/socket] to use.
         The socket(s) to bind to in daemon mode specified using one or more
         tcp://host:port/path, unix:///path/to/socket, fd://* or fd://socketfd.
         If the tcp port is not specified, then it will default to either 2375 when
         --tls is off, or 2376 when --tls is on, or --tlsverify is specified.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta opción debe pasarse en el arranque del &lt;em&gt;daemon&lt;/em&gt; de Docker. Para configurar esta opción durante el arranque de Docker Engine tenemos dos opciones:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;modificar el arranque del &lt;em&gt;daemon&lt;/em&gt; modificando la configuración de &lt;code&gt;/lib/systemd/system/docker.service&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;añadiendo las opciones en el fichero de configuración de Docker Engine. Para sistemas Linux con &lt;em&gt;systemd&lt;/em&gt;, la &lt;a href=&#34;https://docs.docker.com/engine/admin/systemd/#start-automatically-at-system-boot&#34;&gt;configuración del &lt;em&gt;daemon&lt;/em&gt; de Docker&lt;/a&gt; se realiza a través del fichero &lt;code&gt;daemon.json&lt;/code&gt; ubicado en &lt;code&gt;/etc/docker/&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;He intentado configurar Docker Engine mediante el segundo método &lt;em&gt;daemon.json&lt;/em&gt; pero no he sido capaz de activar el API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Primero, hacemos una copia de seguridad del fichero &lt;code&gt;/lib/systemd/system/docker.service&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# cp /lib/systemd/system/docker.service /lib/systemd/system/docker.service.original
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Editamos el fichero &lt;code&gt;/lib/systemd/system/docker.service&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nano /lib/systemd/system/docker.service
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target docker.socket firewalld.service
Wants=network-online.target
Requires=docker.socket

[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
ExecStart=/usr/bin/dockerd -H fd:// 
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=1048576
# Having non-zero Limit*s causes performance problems due to accounting overhead
# in the kernel. We recommend using cgroups to do container-local accounting.
LimitNPROC=infinity
LimitCORE=infinity
# Uncomment TasksMax if your systemd version supports it.
# Only systemd 226 and above support this version.
#TasksMax=infinity
TimeoutStartSec=0
# set delegate yes so that systemd does not reset the cgroups of docker containers
Delegate=yes
# kill only the docker process, not all processes in the cgroup
KillMode=process
# restart the docker process if it exits prematurely
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modificamos la línea &lt;code&gt;ExecStart=/usr/bin/dockerd -H fd://&lt;/code&gt; y añadimos: &lt;code&gt;-H tcp://0.0.0.0:2375&lt;/code&gt; de manera que quede:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Esto hace que &lt;em&gt;dockerd&lt;/em&gt; escuche en todas las interfaces disponibles. En el caso de la máquina virtual en la que estoy probando, sólo tengo una, pero lo correcto sería especificar la dirección IP donde quieres que escuche &lt;em&gt;dockerd&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Guardamos los cambios.&lt;/p&gt;

&lt;p&gt;Recargamos la configuración y reiniciamos el servicio.&lt;/p&gt;

&lt;p&gt;Para comprobar que hemos el API funciona, lanzamos una consulta usando &lt;em&gt;curl&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# systemctl daemon-reload
# systemctl restart docker
# curl http://localhost:2375/version
{&amp;quot;Version&amp;quot;:&amp;quot;17.05.0-ce&amp;quot;,&amp;quot;ApiVersion&amp;quot;:&amp;quot;1.29&amp;quot;,&amp;quot;MinAPIVersion&amp;quot;:&amp;quot;1.12&amp;quot;,&amp;quot;GitCommit&amp;quot;:&amp;quot;89658be&amp;quot;,&amp;quot;GoVersion&amp;quot;:&amp;quot;go1.7.5&amp;quot;,&amp;quot;Os&amp;quot;:&amp;quot;linux&amp;quot;,&amp;quot;Arch&amp;quot;:&amp;quot;amd64&amp;quot;,&amp;quot;KernelVersion&amp;quot;:&amp;quot;3.16.0-4-amd64&amp;quot;,&amp;quot;BuildTime&amp;quot;:&amp;quot;2017-05-04T22:04:27.257991431+00:00&amp;quot;}
#
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Debes tener en cuenta que esta configuración &lt;strong&gt;supone un riesgo de seguridad&lt;/strong&gt; al permitir el acceso al API de Docker Engine sin ningún tipo de control.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Tags, categorias y organización en Hugo</title>
      <link>https://onthedock.github.io/post/170506-tags-categorias-archetypes-en-hugo/</link>
      <pubDate>Sat, 06 May 2017 06:23:50 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170506-tags-categorias-archetypes-en-hugo/</guid>
      <description>&lt;p&gt;A medida que aumenta el número de artículos me he dado cuenta de que es necesario tener algún conjunto de reglas para organizar los ficheros que componen el blog.&lt;/p&gt;

&lt;p&gt;El problema no está en los ficheros de Hugo, sino en los ficheros generados por mi: artículos, imágenes, etc.
&lt;/p&gt;

&lt;p&gt;Hugo genera sitios web a partir de un conjunto de ficheros organizados en carpetas: el contenido se encuentra en &lt;code&gt;$HUGO/content&lt;/code&gt;, las imágenes en &lt;code&gt;$HUGO/static/images&lt;/code&gt; (o dentro de la carpeta equivalente del &lt;em&gt;theme&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Con unos pocos artículos, es fácil identificar qué fichero corresponde a un artículo concreto (simplemente a partir del título). Pero cuando el número de ficheros aumenta, la cosa se complica; el sistama operativo ordena los ficheros por orden alfabético, mientras que en el blog están organizados por fecha de creación. Para complicar más las cosas, el nombre del fichero &lt;em&gt;puede&lt;/em&gt; no ser el mismo que el título del artículo.&lt;/p&gt;

&lt;p&gt;Pasa algo parecido con las imágenes; con unas pocas no hay problema, pero cuando tenga un montón, será complicado identificar qué imagen corresponde a cada artículo.&lt;/p&gt;

&lt;p&gt;Para evitar complicaciones, creo que lo mejor es definir unas reglas sobre cómo organizar el contenido y definir &lt;em&gt;consistentemente&lt;/em&gt; etiquetas, categorías, etc.&lt;/p&gt;

&lt;h2 id=&#34;categorías&#34;&gt;Categorías&lt;/h2&gt;

&lt;p&gt;El blog está orientado al &lt;em&gt;DIY tecnológico&lt;/em&gt; en el aprendizaje sobre contenedores y tecnologías relacionadas.&lt;/p&gt;

&lt;p&gt;En este sentido, para simplificar, he decidido limitarme a dos categorías básicas &lt;code&gt;Dev&lt;/code&gt; y &lt;code&gt;Ops&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;De momento estoy montando el clúster de Kubernetes, realizando troubleshooting, etc, por lo que la mayoría de artículos son de la categoría &lt;code&gt;Ops&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cuando tenga el clúster montado y pueda crear &lt;em&gt;pods&lt;/em&gt; (&lt;em&gt;replication controllers&lt;/em&gt;, etc), empezaré con la parte más &lt;code&gt;Dev&lt;/code&gt;; de momento, los únicos artículos &lt;code&gt;Dev&lt;/code&gt; son los relacionados con Hugo, su configuración, etc.&lt;/p&gt;

&lt;h2 id=&#34;etiquetas&#34;&gt;Etiquetas&lt;/h2&gt;

&lt;p&gt;El objetivo de las etiquetas es permitir organizar de forma flexible los artículos en conjuntos relacionados. Esta flexibilidad puede degenerar rápidamente en un montón de etiquetas que se usan sólo una vez y que no aportan nada.&lt;/p&gt;

&lt;p&gt;Para evitar definir un conjunto de etiquetas estricto -y perder flexibilidad- he pensado que lo mejor es definir unas &lt;em&gt;reglas&lt;/em&gt; sobre qué etiquetas son necesarias en cada artículo.&lt;/p&gt;

&lt;p&gt;Ya he utilizado este sistema en otra ocasión y ha funcionado mucho mejor que otras alternativas que intenté en el pasado.&lt;/p&gt;

&lt;p&gt;La primera etiqueta se refiere a la arquitectura; puede ser &lt;code&gt;x64&lt;/code&gt; o &lt;code&gt;arm&lt;/code&gt;, básicamente. En el primer caso entran tanto equipos físicos como máquinas virtuales; en este caso, no uso ninguna etiqueta concreta (esta es la arquitectura &lt;em&gt;default&lt;/em&gt; para contenedores).&lt;/p&gt;

&lt;p&gt;En el segundo tenemos las Raspberry Pi, para las que uso la etiqueta &lt;code&gt;RASPBERRY PI&lt;/code&gt;, aunque igual me planteo usar &lt;code&gt;ARM&lt;/code&gt; (o las dos). Esto es porque no descarto &lt;em&gt;ampliar la familia&lt;/em&gt; e incorporar alguna Orange Pi al clúster.&lt;/p&gt;

&lt;p&gt;El siguiente nivel sería identificar el sistema operativo: hasta ahora sólo estoy usando Debian (en máquinas virtuales) o Hypriot OS (en las Raspberry Pi). Si en algún momento empiezo a probar contenedores sobre Windows, sólo tengo que añadir esta etiqueta.&lt;/p&gt;

&lt;p&gt;Por encima del sistema operativo tendría la capa de producto: Docker o Kubernetes, por el momento. También  Hugo, por ejemplo, aunque no sea el objetivo principal del blog.&lt;/p&gt;

&lt;p&gt;Finalmente, alguna etiqueta específica sobre el tema del artículo.&lt;/p&gt;

&lt;p&gt;Creo que esta organización de etiquetas permite identificar todo el &lt;em&gt;stack&lt;/em&gt; usado y así distinguir, especialmente pasado un tiempo, qué componentes estaba usando en cada momento (aunque no se expliciten en el artículo).&lt;/p&gt;

&lt;p&gt;Sería interesante poder incluir el número de versión de &lt;em&gt;cada capa&lt;/em&gt; (RPi 1,2,3, versión del SO, de Docker y Kubernetes&amp;hellip;) pero no se me ocurre cómo hacerlo de manera que sea a la vez útil para agrupar artículos y sin provocar &lt;em&gt;ruido&lt;/em&gt; (mogollón de etiquetas similares, como con &lt;code&gt;raspberry pi&lt;/code&gt;, &lt;code&gt;raspberry pi 2&lt;/code&gt; para poder agrupar por RPi, pero también sobre sólo los artículos sobre RPi2 y no los RPi 3, por ejemplo).&lt;/p&gt;

&lt;h2 id=&#34;fecha-en-el-nombre-de-fichero&#34;&gt;Fecha en el nombre de fichero&lt;/h2&gt;

&lt;p&gt;Para que los ficheros se muestren en un orden similar en el blog y en el sistema de ficheros del portátil, el truco es sencillo: los prefijo con la fecha: &lt;code&gt;yymmdd-nombre-articulo.md&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No es habitual que escriba varios artículos el mismo día, pero incluso cuando lo hago, diferenciar entre dos o tres artículos no supone un problema.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;$ ls -la content/post/
...
2.6K Apr 30 15:18 170430-k3-colgado-de-nuevo.md
3.5K Apr 30 12:23 170430-multiples-mensajes-action-17-suspended.md
 12K May  6 05:23 170430-troubleshooting-kubernetes-i.md
6.1K May  5 22:51 170505-instala-weave-net-en-kubernetes-1.6.md
4.6K May  6 08:33 170506-tags-categorias-archetypes-en-hugo.md
6.0K May  6 06:11 170506-troubleshooting-kubernetes-ii.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En cuanto al nombre del fichero, uso el guión &lt;code&gt;-&lt;/code&gt; como sustituyo del espacio en el nombre del fichero. Si cambio el título del artículo, renombro el fichero para que &lt;strong&gt;siempre&lt;/strong&gt; el nombre del fichero y el artículo coincidan el máximo posible.&lt;/p&gt;

&lt;h2 id=&#34;agrupar-imágenes&#34;&gt;Agrupar imágenes&lt;/h2&gt;

&lt;p&gt;Al estar conectado por consola a las máquinas virtuales o las Raspberry Pi, no suelo hacer muchas capturas de pantalla.&lt;/p&gt;

&lt;p&gt;En un blog o un wiki, la propia plataforma se encarga de gestionar las imágenes y nunca he tenido problema porque dos imágenes tuvieran el mismo nombre. La inclusión de la imagen en el artículo se realiza de forma gráfica, por lo que el nombre de la imagen tampoco era importante.&lt;/p&gt;

&lt;p&gt;Sin embargo, al escribir los artículos en markdown y tener que enlazar las imágenes manualmente, el nombre del fichero de la imagen &lt;strong&gt;es relevante&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;He decidido crear una carpeta para evitar problemas de &lt;em&gt;colisión de nombres&lt;/em&gt; y tener organizadas todas las imágenes de un mismo artículo. El nombre de la carpeta corresponde a la fecha del artículo (de nuevo, en formato &lt;code&gt;yymmdd&lt;/code&gt;). Dentro de cada carpeta las imágenes se llaman como se tengan que llamar (de manera que tengan un nombre descriptivo) pero sin preocuparme de si ya existe otra imagen con el mismo nombre de fichero.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Publica en Github Pages</title>
      <link>https://onthedock.github.io/post/170403-publica-en-github-pages/</link>
      <pubDate>Mon, 03 Apr 2017 22:38:35 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170403-publica-en-github-pages/</guid>
      <description>&lt;p&gt;Cómo publicar el sitio web generado con Hugo en GitHub Pages.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Siguiendo las instrucciones de la página de Hugo sobre &lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/#hosting-personal-organization-pages&#34;&gt;cómo publicar en Github Pages&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creo un repo llamado &lt;code&gt;onthedock.github.io&lt;/code&gt;: este albergará el sitio público.&lt;/li&gt;
&lt;li&gt;Creo un repo llamado &lt;code&gt;onthedock-hugo&lt;/code&gt; que contendrá todo el site: ficheros de hugo, el template, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Creo una carpeta local llamada &lt;code&gt;onthedock-githubpages&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dentro de la carpeta, lanzo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git clone https://github.com/onthedock/onthedock-hugo.git`
Cloning into &#39;.&#39;...
warning: You appear to have cloned an empty repository.
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compruebo que tengo un repositorio local inicializado:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git status
On branch master

Initial commit

nothing to commit (create/copy files and use &amp;quot;git add&amp;quot; to track)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copio el contenido del &lt;em&gt;site&lt;/em&gt; de Hugo (que previamente he movido a otra carpeta):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git status
On branch master
Initial commit
Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)
	config.toml
	content/
	static/
	themes/
nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Las carpetas vacías no se añaden a Git.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eliminamos la carpeta &lt;code&gt;$HUGO/public&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Añadimos un &lt;a href=&#34;https://git-scm.com/book/es/v1/Las-herramientas-de-Git-Subm%C3%B3dulos&#34;&gt;&lt;em&gt;submodulo&lt;/em&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git submodule add -b master https://github.com/onthedock/onthedock.github.io.git public
Cloning into &#39;/Users/xavi/Dropbox/dev/hugo/onthedock-githubpages/public&#39;...
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comprobamos el estado del repositorio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git status
On branch master

Initial commit

Changes to be committed:
  (use &amp;quot;git rm --cached &amp;lt;file&amp;gt;...&amp;quot; to unstage)

	new file:   .gitmodules
	new file:   public

Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	config.toml
	content/
	static/
	themes/

$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Añadimos los ficheros del &lt;em&gt;andamiaje&lt;/em&gt; de Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git add .
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Verifico que el repositorio &lt;em&gt;remoto&lt;/em&gt; es el correcto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git remote -v
origin	https://github.com/onthedock/onthedock-hugo.git (fetch)
origin	https://github.com/onthedock/onthedock-hugo.git (push)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y subo el sitio al &lt;em&gt;repo&lt;/em&gt; remoto: &lt;code&gt;onthedock-hugo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$  git push origin master
error: src refspec master does not match any.
error: failed to push some refs to &#39;https://github.com/onthedock/onthedock-hugo.git&#39;
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oopps.&lt;/p&gt;

&lt;p&gt;El problema era que no había guardado ningún cambio, por lo que no existía la rama &lt;code&gt;master&lt;/code&gt;. Aunque he interpretado correctamente el mensaje, he corregido el problema en el extremo opuesto (en el repositorio remoto); he creado un fichero &lt;code&gt;License.md&lt;/code&gt; y he lanzado &lt;code&gt;git pull&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git pull origin
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/onthedock/onthedock-hugo
 * [new branch]      master     -&amp;gt; origin/master
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt; hace un &lt;code&gt;git fetch&lt;/code&gt; y un &lt;code&gt;git merge&lt;/code&gt;, lo que crea un &lt;em&gt;commit&lt;/em&gt; (que era lo que me faltaba por hacer):&lt;/p&gt;

&lt;p&gt;Vuelvo a intentarlo y esta vez sí:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git commit

(había añadido los cambios al _staging area_ pero no los había guardado con _commit_)

$ git push origin master
Username for &#39;https://github.com&#39;: onthedock
Password for &#39;https://onthedock@github.com&#39;:
Counting objects: 64, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (56/56), done.
Writing objects: 100% (64/64), 3.28 MiB | 547.00 KiB/s, done.
Total 64 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), done.
To https://github.com/onthedock/onthedock-hugo.git
   92f53f2..5ecc4bc  master -&amp;gt; master
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora voy a generar el sitio (después de actualizar el fichero &lt;code&gt;config.toml&lt;/code&gt; para que el parámetro &lt;code&gt;baseURL&lt;/code&gt; apunte a la dirección &lt;em&gt;pública&lt;/em&gt; del sitio en GitHub):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ hugo
Started building sites ...
Built site for language en:
0 draft content
0 future content
0 expired content
6 regular pages created
14 other pages created
0 non-page files copied
12 paginator pages created
8 tags created
2 categories created
total in 68 ms
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
  (commit or discard the untracked or modified content in submodules)

	modified:   public (untracked content)

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El contenido de la carpeta &lt;code&gt;$HUGO/public&lt;/code&gt;  está contenida en un &lt;em&gt;submódulo&lt;/em&gt; de Git.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd public/
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	404.html
	categories/
	images/
	index.html
	index.xml
	page/
	post/
	sitemap.xml
	tags/

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora, desde este &lt;em&gt;sub-repositorio&lt;/em&gt;, lanzo &lt;code&gt;git add&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git add .
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

	new file:   404.html
	new file:   categories/dev/index.html
	new file:   categories/dev/index.xml
	new file:   categories/dev/page/1/index.html
	new file:   categories/index.html
	new file:   categories/ops/index.html
	new file:   categories/ops/index.xml
	new file:   categories/ops/page/1/index.html
.
.
.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lanzo un &lt;em&gt;commit&lt;/em&gt; para guardar los cambios:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Verifico que el repositorio remoto es &lt;code&gt;onthedock.github.io&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git remote -v
origin	https://github.com/onthedock/onthedock.github.io.git (fetch)
origin	https://github.com/onthedock/onthedock.github.io.git (push)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora, subo los cambios al repositorio de GitHub Pages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git push origin master
Username for &#39;https://github.com&#39;: onthedock
Password for &#39;https://onthedock@github.com&#39;:
Counting objects: 104, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (74/74), done.
Writing objects: 100% (104/104), 911.20 KiB | 0 bytes/s, done.
Total 104 (delta 41), reused 0 (delta 0)
remote: Resolving deltas: 100% (41/41), done.
To https://github.com/onthedock/onthedock.git
   49c08af..5432d12  master -&amp;gt; master
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La web estará accesible en los próximos diez minutos, aproximadamente, en &lt;code&gt;http://onthedock.github.io&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;El nombre del repositorio debe ser &lt;code&gt;onthedock.github.io&lt;/code&gt;, y no sólo  &lt;code&gt;onthedock&lt;/code&gt;. Si te pasa como a mi y debes cambiar el nombre del &lt;em&gt;repo&lt;/em&gt; , recuerda que ¡puedes hacerlo!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Se puede renombrar el repositorio desde GitHub, pero eso supone que también hay que actualizar el nombre del repositorio en la configuración del  &lt;em&gt;remote&lt;/em&gt; en el repositorio local.&lt;/p&gt;

&lt;p&gt;Para ello, usa el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git remote set-url origin https://github.com/onthedock/onthedock.github.io.git
$ git remote -v
origin	https://github.com/onthedock/onthedock.github.io.git (fetch)
origin	https://github.com/onthedock/onthedock.github.io.git (push)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez cambiado el nombre del repositorio, tras una corta espera, el sitio ya es accesible a través de &lt;code&gt;https://onthedock.github.io&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Agregar nueva entrada con Hugo</title>
      <link>https://onthedock.github.io/post/170401-agregar-nueva-entrada-con-hugo/</link>
      <pubDate>Sat, 01 Apr 2017 22:36:46 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170401-agregar-nueva-entrada-con-hugo/</guid>
      <description>&lt;p&gt;Cómo publicar una entrada usando Hugo, el generador de sitios estáticos, desde la creación del &lt;em&gt;site&lt;/em&gt; hasta la subida de los ficheros en el servidor web.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;algunas-consideraciones-previas&#34;&gt;Algunas consideraciones previas&lt;/h2&gt;

&lt;p&gt;En primer lugar, es importante que Hugo esté correctamente configurado. Asegúrate de que todos los pequeños detalles estén controlados -como que en el parámetro &lt;code&gt;baseURL&lt;/code&gt; se incluya la &lt;code&gt;/&lt;/code&gt; final- y te evitarás un montón de problemas.&lt;/p&gt;

&lt;p&gt;Si haces pruebas en un entorno de integración o consolidación, el único parámetro que hay que modificar al pasar a producción es la &lt;code&gt;baseURL&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para evitar confusiones, en esta entrada a la ruta al ejecutable de Hugo la llamo &lt;code&gt;$HUGO/hugo&lt;/code&gt;. El servidor web publica la web desde la carpeta &lt;code&gt;~/web&lt;/code&gt;. Supongo que la ruta a &lt;code&gt;hugo&lt;/code&gt; se encuentra en el &lt;code&gt;$PATH&lt;/code&gt; de tu equipo, por lo que puedes ejecutarlo lanzando &lt;code&gt;hugo&lt;/code&gt; sin necesidad de especificar la ruta al comando.&lt;/p&gt;

&lt;h2 id=&#34;crea-del-sitio&#34;&gt;Crea del sitio&lt;/h2&gt;

&lt;p&gt;El primer paso para crear un sitio con Hugo es crear una carpeta llamada y lanzar el comando &lt;code&gt;hugo new site&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir mi-sitio-web
$ cd mi-sitio-web
$ hugo new site mi-sitio-web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación, elige un tema (o crea el tuyo propio con &lt;code&gt;hugo new theme&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Configura los parámetros usados en el tema que hayas escogido en el fichero &lt;code&gt;$HUGO/config.toml&lt;/code&gt; y ¡listo!.&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/170401/hugo-publicacion-01.png&#34; alt=&#34;Agregar nueva entrada con Hugo images/170401/hugo-publicacion-01.png&#34; width=640 height=412 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;h2 id=&#34;crea-una-entrada&#34;&gt;Crea una entrada&lt;/h2&gt;

&lt;p&gt;Para crear una entrada, lanza el comando &lt;code&gt;hugo new post/nombre-entrada.md&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd mi-sitio-web
$ hugo new post/mi-primera-entrada.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta acción crea el fichero &lt;code&gt;$HUGO/content/post/nueva-entrada.md&lt;/code&gt;.&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/170401/hugo-publicacion-02.png&#34; alt=&#34;Agregar nueva entrada con Hugo images/170401/hugo-publicacion-02.png&#34; width=640 height=256 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;h2 id=&#34;edita-la-entrada&#34;&gt;Edita la entrada&lt;/h2&gt;

&lt;p&gt;Abre el fichero de la nueva entrada. Encontrarás algo como:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
title = &amp;quot;mi primera entrada&amp;quot;
thumbnail = &amp;quot;images/thumbnail.png&amp;quot;
categories = [&amp;quot;&amp;quot;]
tags = [&amp;quot;&amp;quot;]
date = &amp;quot;2017-04-01T22:36:46+02:00&amp;quot;

+++

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El contenido de cualquier entrada está compuesto por el &lt;em&gt;frontmatter&lt;/em&gt; (&lt;em&gt;metadata&lt;/em&gt; sobre la entrada) y el contenido de la entrada en sí: cualquier cosa a partir del bloque delimitado por &lt;code&gt;+++&lt;/code&gt;. El contenido &lt;em&gt;por defecto&lt;/em&gt; proviene del contenido de la carpeta &lt;code&gt;$HUGO/theme/{tema-usado}/archetypes/default.md&lt;/code&gt; (el contenido varía según el autor de cada tema).&lt;/p&gt;

&lt;p&gt;Al crear la entrada, además de la información copiada desde el &lt;em&gt;archetype&lt;/em&gt; Hugo añade siempre el título (por defecto, igual que el nombre del fichero) y la fecha.&lt;/p&gt;

&lt;p&gt;Ya puedes escribir tu entrada en cualquier editor de texto. Para dar formato al texto -negritas, cursivas-, crear enlaces, insertar imágenes, etc, se usa el &lt;a href=&#34;https://es.wikipedia.org/wiki/Markdown&#34;&gt;markdown&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para tener una idea de cómo va quedando la entrada, puedes usar &lt;code&gt;hugo server watch&lt;/code&gt;. Hugo incorpora un pequeño servidor web con el que puedes visualizar tu blog en modo &lt;em&gt;borrador&lt;/em&gt;, por llamarlo de algún modo. La opción &lt;code&gt;watch&lt;/code&gt; hace que Hugo regenere automáticamente el blog en cuanto detecte algún cambio. De esta manera puedes ir visualizando cómo queda la entrada antes de publicarla.&lt;/p&gt;

&lt;h2 id=&#34;publica-la-entrada&#34;&gt;Publica la entrada&lt;/h2&gt;

&lt;p&gt;Una vez que satisfecho con la entrada, hay que generar los ficheros que componen el blog.&lt;/p&gt;

&lt;p&gt;El blog es un conjunto de ficheros html, javascript y css en la carpeta &lt;code&gt;$HUGO/public&lt;/code&gt;. Para evitar que se mezclen ficheros de &amp;ldquo;publicaciones&amp;rdquo; anteriores, es recomendable borrar la carpeta antes de generar una nueva versión del blog.&lt;/p&gt;

&lt;p&gt;Para crear estos ficheros a partir de tus entradas y el tema que has escogido, simplemente lanza el comando &lt;code&gt;hugo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Hugo hace su magia y genera todos los ficheros necesarios, analizando el contenido de los ficheros. Estos ficheros se generan en la carpeta $HUGO/public`.&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/170401/hugo-publicacion-03.png&#34; alt=&#34;Agregar nueva entrada con Hugo images/170401/hugo-publicacion-03.png&#34; width=640 height=428 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;h2 id=&#34;sube-los-ficheros-al-servidor-web&#34;&gt;Sube los ficheros al servidor web&lt;/h2&gt;

&lt;p&gt;El siguiente paso es subir el contenido de la carpeta al servidor web.&lt;/p&gt;

&lt;p&gt;Para evitar que se mezclen los ficheros actuales y los nuevos, primero elimina el contenido de la carpeta del servidor.&lt;/p&gt;

&lt;p&gt;Mi servidor web es una Raspberry Pi B+, así que me conecto vía SSH y elimino el contenido de la carpeta &lt;code&gt;~/web&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ssh pirate@rpi.local
pirate@rpi.local: ~ $ cd web
pirate@rpi.local: ~/web $ rm -rf *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Después, copio el contendio de &lt;code&gt;$HUGO/public&lt;/code&gt; a &lt;code&gt;~/web&lt;/code&gt; en el servidor remoto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd $HUGO/public
$ scp -r * pirate@rpi.local:/home/pirate/web
&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/170401/hugo-publicacion-04.png&#34; alt=&#34;Agregar nueva entrada con Hugo images/170401/hugo-publicacion-04.png&#34; width=640 height=428 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;p&gt;Desde un navegador, comprueba que el blog se ha actualizado con la nueva entrada.&lt;/p&gt;

&lt;p&gt;Puedes descargar la referencia para todo el proceso: &lt;a href=&#34;../../images/170401/hugo-publicacion-paso-a-paso.png&#34;&gt;Publicación en Hugo: Referencia&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>De Blogger a Hugo</title>
      <link>https://onthedock.github.io/post/170401-de-blogger-a-hugo/</link>
      <pubDate>Sat, 01 Apr 2017 18:10:12 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170401-de-blogger-a-hugo/</guid>
      <description>&lt;p&gt;Porqué me estoy planteando dejar Blogger y pasar a un sitio estático gracias a Hugo.&lt;/p&gt;

&lt;p&gt;Hugo es un &lt;em&gt;generador de sitios estáticos&lt;/em&gt; a partir de ficheros en formato &lt;em&gt;markdown&lt;/em&gt;. Hugo aplica una plantilla al contenido de los ficheros en formato &lt;em&gt;markdon&lt;/em&gt; y crea los ficheros HTML.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;motivación&#34;&gt;Motivación&lt;/h2&gt;

&lt;p&gt;Aunque llevo &lt;em&gt;toda la vida&lt;/em&gt; con un blog personal en &lt;a href=&#34;https://www.blogger.com/&#34;&gt;Blogger&lt;/a&gt;, Google ha desatendido la plataforma y poco a poco se ha ido quedando atrás en prestaciones.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ghost.org&#34;&gt;Ghost&lt;/a&gt; es la platforma que cada vez más desarrolladores y escritores &lt;em&gt;técnicos&lt;/em&gt; usan, tanto en la versión alojada como en sus propias instalaciones. Es la que me gustaría usar para mis blogs: soporta &lt;em&gt;markdown&lt;/em&gt; y no se entromete en el proceso ni de escribir ni de publicar los artículos.&lt;/p&gt;

&lt;p&gt;Mi objetivo era ejecutar Ghost en la Raspberry Pi, pero al no existir soporte de SQLite para la arquitectura ARM, las imágenes para &lt;a href=&#34;https://github.com/alexellis/ghost-on-docker&#34;&gt;&lt;em&gt;contenedores&lt;/em&gt; Docker&lt;/a&gt; están desactualizadas y no siempre son fáciles de &lt;em&gt;construir&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por otro lado, el objetivo del blog en la Raspberry Pi es documentar el proceso de aprendizaje sobre  Docker y Kubernetes (además de Linux). A diferencia de lo que pasaba en mi anterior trabajo, donde estuve usando Hugo de forma &lt;em&gt;experimental&lt;/em&gt;, ahora estas notas no contienen ningún tipo de información privada, por lo que publicaré también los artículos en internet.&lt;/p&gt;

&lt;p&gt;En mis pruebas Hugo se integró en el flujo de trabajo diario sin interferir lo más mínimo, por lo que resultó una experiencia muy positiva.&lt;/p&gt;

&lt;p&gt;Quiero combinar este blog (orientado al avance, a las pruebas, es decir, al proceso) con Dokuwiki (como almacén de conocimiento y documentación). Sin embargo, con Dokuwiki la  &lt;em&gt;dualidad&lt;/em&gt; entre en entorno &lt;em&gt;local&lt;/em&gt; (en casa) y en internet es más difícil de conseguir de forma directa (usando recursos gratuitos). Tengo un &lt;a href=&#34;http://wiki-ameisin.rhcloud.com/&#34;&gt;contenedor en OpenShift&lt;/a&gt; con notas sobre diferentes temas, pero en esta instancia de Dokuwiki en OpenShift las carpetas de datos tienen una estructura diferente a la estándar, lo que dificulta mantener &lt;em&gt;sincronizadas&lt;/em&gt; la versión &lt;em&gt;local&lt;/em&gt; y la alojada en el &lt;em&gt;cloud&lt;/em&gt; de Red Hat.&lt;/p&gt;

&lt;h2 id=&#34;hugo&#34;&gt;Hugo&lt;/h2&gt;

&lt;p&gt;La idea detrás de un generador de sitios estáticos es que, en muchas ocasiones, no es necesario disponer de toda la potencia que ofrecen las plataformas de &lt;em&gt;blogging&lt;/em&gt; modernas como &lt;a href=&#34;https://wordpress.org&#34;&gt;Wordpress&lt;/a&gt;, etc. Además, estas plataformas no son siempre fáciles de instalar, configurar y mantener en tu propio entorno local.&lt;/p&gt;

&lt;p&gt;La alternativa es mantener un sitio web a partir de ficheros HTML independientes, pero resulta muy costoso en tiempo y esfuerzo.&lt;/p&gt;

&lt;p&gt;A medio camino se encuentran los generadores de sitios como &lt;a href=&#34;https://jekyllrb.com&#34;&gt;Jekill&lt;/a&gt; o &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Estos &lt;em&gt;generadores de sitios estáticos&lt;/em&gt; parten de ficheros en formato &lt;em&gt;markdown&lt;/em&gt; -que son sencillos de escribir- y se encargan de combinarlos con unas plantillas, generar los enlaces entre los diferentes artículos, crear nubes de etiquetas, etc (la parte tediosa) hasta generar los ficheros HTML.&lt;/p&gt;

&lt;p&gt;Al final del proceso, tenemos un conjunto de ficheros &lt;em&gt;web&lt;/em&gt; (HTML, javascript, css) que podemos alojar en cualquier servidor (o en servicios como &lt;a href=&#34;https://pages.github.com&#34;&gt;GitHub Pages&lt;/a&gt; o &lt;a href=&#34;https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html&#34;&gt;Bitbucket&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;siguientes-pasos&#34;&gt;Siguientes pasos&lt;/h2&gt;

&lt;p&gt;En estas fase inicial, únicamente tengo un contenedor con un servidor web (Nginx) sirviendo el sitio estático generado por Hugo (en un portátil).&lt;/p&gt;

&lt;p&gt;Más adelante quiero incluir también un contenedor con Hugo (como el proporcionado por &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-hugo/&#34;&gt;Hypriot&lt;/a&gt;) e ir añadiendo poco a poco todas las herramientas del proceso de Integración Continua -en forma de contenedores- desde el &lt;em&gt;código fuente&lt;/em&gt; al sitio web publicado automáticamente con cada cambio. Como se apunta en la entrada &lt;a href=&#34;https://blog.hypriot.com/post/static-website-generation-on-steriods-with-docker/&#34;&gt;Static Website Generation on Steriods with Docker&lt;/a&gt;, la idea es montar una cadena de &lt;a href=&#34;https://es.wikipedia.org/wiki/Integración_continua&#34;&gt;CI&lt;/a&gt;: GoGS (repositorio de código &lt;em&gt;a lo Github&lt;/em&gt;), &lt;a href=&#34;https://github.com/drone/drone&#34;&gt;Drone&lt;/a&gt; (el &lt;em&gt;motor&lt;/em&gt; de Integración Continua: como &lt;a href=&#34;https://es.wikipedia.org/wiki/Jenkins&#34;&gt;Jenkins&lt;/a&gt;, pero escrito en Go) y para el &lt;em&gt;deployment&lt;/em&gt;, una mezcla de &lt;a href=&#34;https://hub.docker.com/r/xaviaznar/rpi-alpine-nginx/&#34;&gt;Nginx&lt;/a&gt; (publicación local) y &lt;a href=&#34;https://bitbucket.org/product&#34;&gt;Bitbucket&lt;/a&gt; (publicación en internet).&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>