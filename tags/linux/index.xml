<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on On The Dock</title>
    <link>https://onthedock.github.io/tags/linux/index.xml</link>
    <description>Recent content in Linux on On The Dock</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <atom:link href="https://onthedock.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Solución al error de instalación de Kubernetes en Debian Jessie (Missing cgroups: memory)</title>
      <link>https://onthedock.github.io/post/170422-solucion-al-error-missing-cgroups-memory-en-debian-jessie/</link>
      <pubDate>Sat, 22 Apr 2017 07:57:14 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170422-solucion-al-error-missing-cgroups-memory-en-debian-jessie/</guid>
      <description>&lt;p&gt;Al lanzar la inicialización del clúster con &lt;code&gt;kubeadm init&lt;/code&gt; en Debian Jessie, las comprobaciones inciales indican que no se encuentran los &lt;em&gt;cgroups&lt;/em&gt; para la memoria (échale un vistazo al artículo &lt;a href=&#34;https://onthedock.github.io/post/170417-instalacion-de-kubernetes-falla-missing-cgroups-memory/&#34;&gt;La instalación de Kubernetes falla en Debian Jessie (missing cgroups: memory)&lt;/a&gt;). Los &lt;em&gt;cgroups&lt;/em&gt; son una de las piezas fundamentales en las que se basa Docker para &lt;em&gt;aislar&lt;/em&gt; los procesos de los contenedores, por lo que la inicialización del clúster de Kubernetes se detiene.&lt;/p&gt;

&lt;p&gt;La solución es tan sencilla como habilitar los &lt;em&gt;cgroups&lt;/em&gt; durante el arranque.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;En primer lugar, verificamos la versión del &lt;em&gt;kernel&lt;/em&gt; que tenemos instalada:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# uname -a
Linux k8s 3.16.0-4-amd64 #1 SMP Debian 3.16.39-1+deb8u2 (2017-03-07) x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Al lanzar &lt;code&gt;kubeadm init&lt;/code&gt; obtenemos el error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# kubeadm init
[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.
[init] Using Kubernetes version: v1.6.0
[init] Using Authorization mode: RBAC
[preflight] Running pre-flight checks
[preflight] The system verification failed. Printing the output from the verification:
OS: Linux
KERNEL_VERSION: 3.16.0-4-amd64
CONFIG_NAMESPACES: enabled
CONFIG_NET_NS: enabled
CONFIG_PID_NS: enabled
CONFIG_IPC_NS: enabled
CONFIG_UTS_NS: enabled
CONFIG_CGROUPS: enabled
CONFIG_CGROUP_CPUACCT: enabled
CONFIG_CGROUP_DEVICE: enabled
CONFIG_CGROUP_FREEZER: enabled
CONFIG_CGROUP_SCHED: enabled
CONFIG_CPUSETS: enabled
CONFIG_MEMCG: enabled
CONFIG_INET: enabled
CONFIG_EXT4_FS: enabled (as module)
CONFIG_PROC_FS: enabled
CONFIG_NETFILTER_XT_TARGET_REDIRECT: enabled (as module)
CONFIG_NETFILTER_XT_MATCH_COMMENT: enabled (as module)
CONFIG_OVERLAYFS_FS: not set - Required for overlayfs.
CONFIG_AUFS_FS: enabled (as module)
CONFIG_BLK_DEV_DM: enabled (as module)
CGROUPS_CPU: enabled
CGROUPS_CPUACCT: enabled
CGROUPS_CPUSET: enabled
CGROUPS_DEVICES: enabled
CGROUPS_FREEZER: enabled
CGROUPS_MEMORY: missing
DOCKER_VERSION: 17.04.0-ce
[preflight] WARNING: docker version is greater than the most recently validated version. Docker version: 17.04.0-ce. Max validated version: 1.12
[preflight] Some fatal errors occurred:
	missing cgroups: memory
[preflight] If you know what you are doing, you can skip pre-flight checks with `--skip-preflight-checks`
#
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solución&#34;&gt;Solución&lt;/h2&gt;

&lt;p&gt;La solución la he encontrado en &lt;a href=&#34;https://phabricator.wikimedia.org/T122734&#34;&gt;Enable memory cgroups for default Jessie image&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nos convertimos en &lt;em&gt;root&lt;/em&gt;: &lt;code&gt;sudo su -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Editamos el fichero &lt;code&gt;/etc/default/grup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;En los parámetros para el arranque de linux (&lt;code&gt;GRUB_CMDLINE_LINUX&lt;/code&gt;) añadimos &lt;code&gt;cgroup_enable=memory&lt;/code&gt;. En mi caso, la línea queda: &lt;code&gt;GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet cgroup_enable=memory&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Actualizamos &lt;em&gt;grub&lt;/em&gt;: &lt;code&gt;update-grub2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reiniciamos la máquina: &lt;code&gt;reboot&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;...
[preflight] WARNING: docker version is greater than the most recently validated version. Docker version: 17.04.0-ce. Max validated version: 1.12
[preflight] Some fatal errors occurred:
	missing cgroups: memory
[preflight] If you know what you are doing, you can skip pre-flight checks with `--skip-preflight-checks`
root@k8s:~# nano /etc/default/grub
root@k8s:~# update-grub2
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-3.16.0-4-amd64
Found initrd image: /boot/initrd.img-3.16.0-4-amd64
done
root@k8s:~# reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Al lanzar &lt;code&gt;kubeadm init&lt;/code&gt; de nuevo, el clúster arranca con normalidad:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@k8s:~# kubeadm init
[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.
[init] Using Kubernetes version: v1.6.0
[init] Using Authorization mode: RBAC
[preflight] Running pre-flight checks
[preflight] WARNING: docker version is greater than the most recently validated version. Docker version: 17.04.0-ce. Max validated version: 1.12
[certificates] Generated CA certificate and key.
[certificates] Generated API server certificate and key.
[certificates] API Server serving cert is signed for DNS names [k8s kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.1.99]
[certificates] Generated API server kubelet client certificate and key.
[certificates] Generated service account token signing key and public key.
[certificates] Generated front-proxy CA certificate and key.
[certificates] Generated front-proxy client certificate and key.
[certificates] Valid certificates and keys now exist in &amp;quot;/etc/kubernetes/pki&amp;quot;
[kubeconfig] Wrote KubeConfig file to disk: &amp;quot;/etc/kubernetes/scheduler.conf&amp;quot;
[kubeconfig] Wrote KubeConfig file to disk: &amp;quot;/etc/kubernetes/admin.conf&amp;quot;
[kubeconfig] Wrote KubeConfig file to disk: &amp;quot;/etc/kubernetes/kubelet.conf&amp;quot;
[kubeconfig] Wrote KubeConfig file to disk: &amp;quot;/etc/kubernetes/controller-manager.conf&amp;quot;
[apiclient] Created API client, waiting for the control plane to become ready
[apiclient] All control plane components are healthy after 39.363656 seconds
[apiclient] Waiting for at least one node to register
[apiclient] First node has registered after 1.518215 seconds
[token] Using token: fe9e91.7142118e712eb019
[apiconfig] Created RBAC rules
[addons] Created essential addon: kube-proxy
[addons] Created essential addon: kube-dns

Your Kubernetes master has initialized successfully!

To start using your cluster, you need to run (as a regular user):

  sudo cp /etc/kubernetes/admin.conf $HOME/
  sudo chown $(id -u):$(id -g) $HOME/admin.conf
  export KUBECONFIG=$HOME/admin.conf

You should now deploy a pod network to the cluster.
Run &amp;quot;kubectl apply -f [podnetwork].yaml&amp;quot; with one of the options listed at:
  http://kubernetes.io/docs/admin/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join --token fe9e91.7142118e712eb019 192.168.1.99:6443

root@k8s:~#
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Configura curl para usar un proxy</title>
      <link>https://onthedock.github.io/post/170111-configura-curl-para-usar-proxy/</link>
      <pubDate>Wed, 11 Jan 2017 08:22:56 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/170111-configura-curl-para-usar-proxy/</guid>
      <description>&lt;p&gt;Cómo configurar &lt;code&gt;curl&lt;/code&gt; para salir a internet a través de un &lt;em&gt;proxy&lt;/em&gt; que requiere autenticación.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Como la VM está detrás de un &lt;em&gt;proxy&lt;/em&gt;, primero tienes que indicar a &lt;code&gt;curl&lt;/code&gt; la dirección del mismo. La manera más sencilla de solucionar el problema de una vez por todas es indicar la URL del &lt;em&gt;proxy&lt;/em&gt; en el fichero &lt;code&gt;.curlrc&lt;/code&gt;, en la carpeta &lt;em&gt;home&lt;/em&gt; del usuario.&lt;/p&gt;

&lt;p&gt;Si estás trabajando con el usuario &lt;code&gt;root&lt;/code&gt;, coloca el fichero en &lt;code&gt;/root/.curlrc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Edita el fichero y añade la dirección del &lt;em&gt;proxy&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;proxy = https://${USERNAME}:${PASSWORD}@proxy.ameisin.com:8080/proxy.pac
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Referencia: &lt;a href=&#34;http://stackoverflow.com/questions/7559103/how-to-setup-curl-to-permanently-use-a-proxy&#34;&gt;How to setup curl to permanently use a proxy? [closed]&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Instala Docker en Ubuntu Server 16.04</title>
      <link>https://onthedock.github.io/post/170110-instala-docker-en-ubuntu-server-16.04/</link>
      <pubDate>Tue, 10 Jan 2017 15:12:46 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/170110-instala-docker-en-ubuntu-server-16.04/</guid>
      <description>&lt;p&gt;Cómo instalar Docker en Ubuntu Server 16.04.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Para instalar la última versión de Docker, usamos las instrucciones &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/como-instalar-y-usar-docker-en-ubuntu-16-04-es&#34;&gt;¿Cómo instalar y usar Docker en Ubuntu 16.04?&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;No funciona por algún motivo, probablemente por el &lt;em&gt;proxy&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Para instalar la clave GPG de Docker, el método que funciona es (&lt;small&gt;ref: &lt;a href=&#34;https://github.com/docker/docker/issues/17436#issuecomment-151870782&#34;&gt;Docker website encourages users to import GPG key for apt repository in unsafe ways #17436&lt;/a&gt;&lt;/small&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# curl -s  https://get.docker.com/gpg | apt-key add -
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agregamos el repositorio de Docker a APT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-add-repository &#39;deb https://apt.dockerproject.org/repo ubuntu-xenial main&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actualizamos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez añadido, comprobamos mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-cache policy docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finalmente, instalamos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install -y docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si ha habido problemas para validar la autenticidad del paquete de Docker, la instalación debe hacerse sin la aceptación automática (es decir, sin el parámetro &lt;code&gt;-y&lt;/code&gt;) o añadiendo &lt;code&gt;--allow-authenticate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Verificamos que tenemos docker funcionando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# docker version
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Configura el proxy para APT en Ubuntu Server 16.04</title>
      <link>https://onthedock.github.io/post/170110-configura-apt-en-ubuntu-server-16.04/</link>
      <pubDate>Tue, 10 Jan 2017 15:01:55 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/170110-configura-apt-en-ubuntu-server-16.04/</guid>
      <description>&lt;p&gt;Cómo configurar &lt;code&gt;apt&lt;/code&gt; para salir a internet a través de un &lt;em&gt;proxy&lt;/em&gt; que requiere autenticación.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;La configuración del &lt;em&gt;proxy&lt;/em&gt; para &lt;code&gt;APT&lt;/code&gt; en Ubuntu Server 16.04 se realiza a través del fichero &lt;code&gt;/etc/apt/apt.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Crea el fichero si no existe y escribe:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Acquire::http::Proxy &amp;quot;http://${USERNAME}:${PASSWORD}@proxy.ameisin.vwg:8080/amisin.pac&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación, ya puedes actualizar los repositorios usando &lt;code&gt;apt-get update&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introducción a Hypriot OS</title>
      <link>https://onthedock.github.io/post/161105-introduccion-a-hypriotos/</link>
      <pubDate>Sat, 05 Nov 2016 10:37:47 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/161105-introduccion-a-hypriotos/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.hypriot.com/about/#hypriotos:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;HypriotOS&lt;/a&gt; es un sistema operativo basado en &lt;a href=&#34;http://www.debian.org/&#34;&gt;Debian&lt;/a&gt; optimizado para ejecutar &lt;a href=&#34;http://www.docker.com/&#34;&gt;Docker&lt;/a&gt; en plataformas ARM como las &lt;a href=&#34;https://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;hypriotos&#34;&gt;HypriotOS&lt;/h1&gt;

&lt;p&gt;Las características principales de HypriotOs son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sistema operativo basado de Debian: la mayor parte de la gente saber cómo usar Debian y las distribuciones basadas en Ubuntu.&lt;/li&gt;
&lt;li&gt;Optimizado para Docker: Todo en HypriotOS está orientado a conseguir que Docker se ejecute de maravilla, desde las configuraciones del kernel de Linux hasta el sistema de ficheros.&lt;/li&gt;
&lt;li&gt;Versiones actualizadas de Docker: Hypriot se actualiza cada vez que se publica una nueva versión de Docker.&lt;/li&gt;
&lt;li&gt;Listo para usar: descargar, &lt;em&gt;flashear&lt;/em&gt; y arrancar, es lo único que hace falta para ponerse en marcha con HypriotOS.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;instalación-de-hypriotos&#34;&gt;Instalación de HypriotOS&lt;/h2&gt;

&lt;p&gt;La instalación de HypriotOS en la Raspberry Pi es muy sencilla.&lt;/p&gt;

&lt;p&gt;En el blog de Hypriot tienes información para grabar la imagen en una tarjeta SD tanto si usas &lt;a href=&#34;http://blog.hypriot.com/getting-started-with-docker-on-your-arm-device/&#34;&gt;Windows, Linux o Mac&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;En mi caso, he usado un equipo con Windows para pasar la imagen a la tarjeta SD siguiendo los siguientes pasos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Descarga la imagen con Hypriot en formato comprimido desde &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;sección de descargas del blog de Hypriot&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Descomprime el &lt;em&gt;zip&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Usa &lt;a href=&#34;http://sourceforge.net/projects/win32diskimager/&#34;&gt;Win32DiskImager&lt;/a&gt; para pasar la imagen descomprimida a la tarjeta SD.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;¡Eso es todo!&lt;/p&gt;

&lt;p&gt;El siguiente paso es colocar de nuevo la tarjeta SD en la Raspberry Pi y arrancar.&lt;/p&gt;

&lt;h2 id=&#34;obtener-la-dirección-ip-de-la-raspberry-pi&#34;&gt;Obtener la dirección IP de la Raspberry Pi&lt;/h2&gt;

&lt;p&gt;Por defecto, la Raspberry Pi con HypriotOS obtiene una dirección IP del DHCP local. En el blog de Hypriot recomiendan usar un programa para escanear tu red local y obtener la dirección asignada a la Raspberry Pi (&lt;a href=&#34;http://sourceforge.net/projects/nmap.mirror/?source=typ_redirect&#34;&gt;ZenMap&lt;/a&gt; o &lt;a href=&#34;http://angryip.org/download/#windows, en los comentarios&#34;&gt;Angry IP Scanner&lt;/a&gt;. En mi caso, he accedido a la lista de clientes a los cuales el DHCP les ha asignado una dirección IP y he obtenido la dirección asignada al equipo llamado &lt;em&gt;black-pearl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una vez obtenida la dirección IP, conéctate usando &lt;a href=&#34;http://the.earth.li/~sgtatham/putty/latest/x86/putty.exe&#34;&gt;&lt;em&gt;Putty&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Introduce la IP asignada a la Raspberry Pi en el campo &lt;em&gt;Host Name (or IP address)&lt;/em&gt; y verifica que el puerto es el 22.&lt;/p&gt;

&lt;p&gt;La primera vez que conectes a la dirección IP de la Raspberry Pi obtendrás un mensaje de aviso indicando si quieres confiar en el equipo.&lt;/p&gt;

&lt;p&gt;Puedes iniciar sesión en la Raspberry Pi usando el nombre de usuario &lt;code&gt;pirate&lt;/code&gt; y el password  &lt;code&gt;hypriot&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finalmente, para verificar que Docker se encuentra presente, ejecuta &lt;code&gt;docker info&lt;/code&gt;. La salida de este comando te devolverá las versiones de cliente y servidor instaladas.&lt;/p&gt;

&lt;h2 id=&#34;crea-tu-primer-contenedor&#34;&gt;Crea tu primer contenedor&lt;/h2&gt;

&lt;p&gt;Ya está todo listo para ejecutar tu primer contenedor. Y es tan sencillo como lanzar el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p 80:80 hypriot/rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este comando ejecuta un contendor (&lt;code&gt;docker run&lt;/code&gt;) en segundo plano, de forma no interactiva (&lt;code&gt;-d&lt;/code&gt;, &lt;em&gt;dettached&lt;/em&gt;), conectando el puerto 80 (web) de tu equipo local con el puerto 80 del contenedor. El contenedor se creará a partir de la imagen &lt;code&gt;hypriot/rpi-busybox-httpd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cuando Docker intenta crear el contenedor, busca la imagen indicada en su registro local. Si no lo encuentra, se conecta a un registro público -por defecto Docker Hub- y busca la imagen allí.&lt;/p&gt;

&lt;p&gt;Una vez localizada la imagen, descarga en el registro local una copia de la imagen y finalmente arranca un contenedor basado en esa imagen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p  80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
19d131999ea3142d44a83a6e943c9052d8defa43f7da372bd08ec441ee55f31b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La imagen descargada contiene &lt;code&gt;busybox&lt;/code&gt; y un servidor web minimalista. Puedes acceder al servidor arrancado en el contenedor a través de un navegador, indicando la IP de la Raspberry Pi.&lt;/p&gt;

&lt;h3 id=&#34;un-contenedor-más-útil&#34;&gt;Un contenedor más útil&lt;/h3&gt;

&lt;p&gt;Como ejemplo de primer contenedor y de lo fácil que es lanzar contenedores con Docker, el ejemplo anterior no está mal.&lt;/p&gt;

&lt;p&gt;Sin embargo, vamos a seguir los mismos pasos para crear un contenedor que proporciona un entorno web de gestión de Docker:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock hypriot/rpi-dockerui
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso observamos que, además de las instrucciones que hemos visto en el caso anterior, tenemos un nuevo parámetro &lt;code&gt;-v&lt;/code&gt;, que permite &lt;em&gt;montar&lt;/em&gt; una ruta local del equipo &lt;em&gt;host&lt;/em&gt; en el contenedor. Sin embargo, no te preocupes si ahora no entindes todos los detalles.&lt;/p&gt;

&lt;p&gt;Una vez arrancado el contenedor, accede a través de un navegador a &lt;code&gt;http://{IP-equipo-docker}:9000&lt;/code&gt;. Desde este entorno web puedes controlar el estado de tu instalación de Docker vía web gracias a &lt;a href=&#34;https://github.com/kevana/ui-for-docker&#34;&gt;UI-for-Docker&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;asigna-una-ip-estática&#34;&gt;Asigna una IP estática&lt;/h2&gt;

&lt;p&gt;En el apartado anterior hemos visto cómo instalar Docker y hemos lanzado los primeros contenedores. Pero la Raspberry Pi sigue con la configuración de la dirección IP dinámica, por lo que puede que la próxima vez que intentes acceder a la RPi, su dirección haya cambiado.&lt;/p&gt;

&lt;p&gt;Para evitar estos problemas, vamos a asignar la IP -estática- 192.168.1.51.&lt;/p&gt;

&lt;p&gt;Abrimos el fichero &lt;code&gt;/etc/network/interfaces&lt;/code&gt; y encontramos que se hace referencia a una carpeta de configuración:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;# interfaces(5) file used by ifup(8) and ifdown(8)
# Include files from /etc/network/interfaces.d:
source-directory /etc/network/interfaces.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abrimos el fichero de configuración de la tarjeta de red &lt;code&gt;eth0&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;allow-hotplug eth0
iface eth0 inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vemos que está configurada en modo &lt;code&gt;DHCP&lt;/code&gt;, por lo que comentamos la segunda línea y especificamos la configuración de IP estática:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;# iface eth0 inet dhcp

# Set static IP 
iface eth0 inet static
address 192.168.1.51
gateway 192.168.1.1
domain_name_servers=8.8.8.8, 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por supuesto, debes indicar la configuración de red de tu entorno.&lt;/p&gt;

&lt;p&gt;Guardamos los cambios y reiniciamos el servicio de red mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo $ sudo /etc/init.d/networking restart
[....] Restarting networking (via systemctl): networking.service
. ok
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Como la IP de la Raspberry Pi ha cambiado, la conexión remota desde tu equipo se perderá.&lt;/p&gt;

&lt;p&gt;Debes conectar de nuevo con la Raspberry Pi usando la IP que acabas de asignar.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;encontrando-tu-raspberry-pi-en-la-red-gracias-a-avahi&#34;&gt;Encontrando tu Raspberry Pi en la red gracias a Avahi&lt;/h3&gt;

&lt;p&gt;Desde la versión 0.3 &lt;em&gt;Jack&lt;/em&gt;, HypriotOS usa &lt;a href=&#34;https://en.wikipedia.org/wiki/Avahi_(software)&#34;&gt;Avahi&lt;/a&gt;, el sistema que permite a los programas publicar y descubrir servicios y hosts en una red local. De esta forma puedes acceder a los servicios publicados por los contenedores vía web (o hacer un ping) usando el nombre del sistema: &lt;strong&gt;&lt;code&gt;black-pearl&lt;/code&gt;&lt;/strong&gt; (por defecto).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;He comprobado que funciona desde un equipo Mac; falta comprobarlo desde un equipo Windows.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>