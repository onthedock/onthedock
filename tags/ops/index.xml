<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ops on On The Dock</title>
    <link>https://onthedock.github.io/tags/ops/index.xml</link>
    <description>Recent content in Ops on On The Dock</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <atom:link href="https://onthedock.github.io/tags/ops/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Instalacion de Kubernetes en Debian Jessie</title>
      <link>https://onthedock.github.io/post/instalacion-de-kubernetes/</link>
      <pubDate>Mon, 17 Apr 2017 19:38:11 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/instalacion-de-kubernetes/</guid>
      <description>&lt;p&gt;La instalación de Kubernetes se realiza de forma casi automática gracias al &lt;em&gt;script&lt;/em&gt; &lt;code&gt;kubeadm&lt;/code&gt;. Sólo hay que seguir las instrucciones de &lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;Installing Kubernetes on Linux with kubeadm&lt;/a&gt; y la salida por pantalla del propio &lt;em&gt;script&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Para no &lt;em&gt;deshacer&lt;/em&gt; la instalación de Kubernetes sobre Raspberry Pi, he creado una máquina virtual con Debian 3 (&lt;em&gt;Jessie&lt;/em&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# uname -a
Linux k8s 3.16.0-4-amd64 #1 SMP Debian 3.16.39-1+deb8u2 (2017-03-07) x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En primer lugar, me he convertido en &lt;code&gt;root&lt;/code&gt; mediante &lt;code&gt;su -&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Uno de los requisitos para instalar Kubernetes es tener Docker instalado. En mi caso, tengo instalado &lt;code&gt;docker-engine&lt;/code&gt;, el paquete de Docker mantenido por Docker Inc. Este paquete y &lt;code&gt;docker.io&lt;/code&gt; (el mantenido por Ubuntu) son equivalentes, aunque tienen numeración de versión diferente.&lt;/p&gt;

&lt;p&gt;Verifico que Docker está instalado:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# docker version
Client:
 Version:      17.04.0-ce
 API version:  1.28
 Go version:   go1.7.5
 Git commit:   4845c56
 Built:        Mon Apr  3 17:45:49 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.04.0-ce
 API version:  1.28 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   4845c56
 Built:        Mon Apr  3 17:45:49 2017
 OS/Arch:      linux/amd64
 Experimental: false
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Antes de empezar la instalación, he actualizado el sistema mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get update &amp;amp;&amp;amp; apt-get upgrade
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A partir de aquí, sigo las instrucciones de la guía oficial.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https
...
Reading state information... Done
apt-transport-https is already the newest version.
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obtenemos la clave GPG de los paquetes de Kubernetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Añadimos el repositorio de Kubernetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list
deb http://apt.kubernetes.io/ kubernetes-xenial main
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y ya sólo nos queda actualizar la información e instalar los componentes de Kubernetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get update
...
Fetched 22.1 kB in 3s (6,784 B/s)
Reading package lists... Done
#
# apt-get install -y kubelet kubeadm kubectl kubernetes-cni
...
Setting up ebtables (2.0.10.4-3) ...
update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults
Setting up ethtool (1:3.16-1) ...
Setting up kubernetes-cni (0.5.1-00) ...
Setting up socat (1.7.2.4-2) ...
Setting up kubelet (1.6.1-00) ...
Setting up kubectl (1.6.1-00) ...
Setting up kubeadm (1.6.1-00) ...
Processing triggers for systemd (215-17+deb8u6) ...
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ya tenemos instalado Kubernetes en nuestro sistema.&lt;/p&gt;

&lt;p&gt;El siguiente paso es inicializar el clúster con &lt;code&gt;kubeadm init&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# kubeadm init
[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.
[init] Using Kubernetes version: v1.6.0
[init] Using Authorization mode: RBAC
[preflight] Running pre-flight checks
[preflight] The system verification failed. Printing the output from the verification:
OS: Linux
KERNEL_VERSION: 3.16.0-4-amd64
CONFIG_NAMESPACES: enabled
CONFIG_NET_NS: enabled
CONFIG_PID_NS: enabled
CONFIG_IPC_NS: enabled
CONFIG_UTS_NS: enabled
CONFIG_CGROUPS: enabled
CONFIG_CGROUP_CPUACCT: enabled
CONFIG_CGROUP_DEVICE: enabled
CONFIG_CGROUP_FREEZER: enabled
CONFIG_CGROUP_SCHED: enabled
CONFIG_CPUSETS: enabled
CONFIG_MEMCG: enabled
CONFIG_INET: enabled
CONFIG_EXT4_FS: enabled (as module)
CONFIG_PROC_FS: enabled
CONFIG_NETFILTER_XT_TARGET_REDIRECT: enabled (as module)
CONFIG_NETFILTER_XT_MATCH_COMMENT: enabled (as module)
CONFIG_OVERLAYFS_FS: not set - Required for overlayfs.
CONFIG_AUFS_FS: enabled (as module)
CONFIG_BLK_DEV_DM: enabled (as module)
CGROUPS_CPU: enabled
CGROUPS_CPUACCT: enabled
CGROUPS_CPUSET: enabled
CGROUPS_DEVICES: enabled
CGROUPS_FREEZER: enabled
CGROUPS_MEMORY: missing
DOCKER_VERSION: 17.04.0-ce
[preflight] WARNING: docker version is greater than the most recently validated version. Docker version: 17.04.0-ce. Max validated version: 1.12
[preflight] WARNING: hostname &amp;quot;k8s&amp;quot; could not be reached
[preflight] WARNING: hostname &amp;quot;k8s&amp;quot; lookup k8s on 80.58.61.254:53: no such host
[preflight] Some fatal errors occurred:
	missing cgroups: memory
[preflight] If you know what you are doing, you can skip pre-flight checks with `--skip-preflight-checks`
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La instalación de Kubernetes falla porque no están habilitados los &lt;em&gt;cgroups&lt;/em&gt; para la memoria. :(&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker-engine vs Docker.io</title>
      <link>https://onthedock.github.io/post/docker-engine_vs_docker.io/</link>
      <pubDate>Mon, 10 Apr 2017 21:30:31 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/docker-engine_vs_docker.io/</guid>
      <description>&lt;p&gt;En función de la distribución que uses, verás que el paquete de instalación de Docker es &lt;code&gt;docker-engine&lt;/code&gt; o &lt;code&gt;docker.io&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;¿Cuál es la diferencia entre uno y otro?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;En la guía de instalación de Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;Installing Kubernetes on Linux with kubeadm&lt;/a&gt; se indica que para instalar Docker, el comando a usar en Ubuntu o HypriotOS es mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get install -y docker.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sin embargo, cuando he lanzado el comando en HypriotOS me ha llamado la atención el aviso &lt;code&gt;The following packages will be REMOVED: docker-engine&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ apt-get install -y docker.io
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following package was automatically installed and is no longer required:
  libltdl7
Use &#39;apt-get autoremove&#39; to remove it.
Suggested packages:
  btrfs-tools debootstrap lxc rinse
The following packages will be REMOVED:
  docker-engine
The following NEW packages will be installed:
  docker.iol
0 upgraded, 1 newy installed, 1 to remove and 0 not upgraded.
Need to get 3,082 kB of archives.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Así que me ha surgido la duda: ¿qué diferencia hay entre &lt;code&gt;docker-engine&lt;/code&gt; y &lt;code&gt;docker.io&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;La respuesta, de la mano de &lt;a href=&#34;https://www.quora.com/What-is-the-difference-between-docker-engine-and-docker-io-packages&#34;&gt;Quora&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker.io&lt;/code&gt; es mantenido por Ubuntu&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-engine&lt;/code&gt; es mantenido por Docker&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker.io&lt;/code&gt; era el antiguo dominio para el Proyecto Docker (ahora &lt;code&gt;docker.com&lt;/code&gt;). Como ya existía un paquete llamado &lt;code&gt;docker&lt;/code&gt; en los repositorios, desde Ubuntu decidieron usar el nombre &lt;code&gt;docker.io&lt;/code&gt; como nombre del paquete del Proyecto Docker.&lt;/p&gt;

&lt;p&gt;Por su parte, el equipo de Docker mantiene una versión propia de su producto para Ubuntu, a la que llaman &lt;code&gt;docker-engine&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Es decir, tanto &lt;code&gt;docker.io&lt;/code&gt; como &lt;code&gt;docker-engine&lt;/code&gt; son &lt;strong&gt;el mismo software&lt;/strong&gt;, pero gestionado por dos entes diferentes: Ubuntu o Docker Inc.&lt;/p&gt;

&lt;p&gt;En mi caso uso HypriotOS, una distribución creada específicamente para Raspberry Pi (plataforma ARM). Los creadores de esta distribución han optado por la versión mantenida por Docker, así que seguiré usando &lt;code&gt;docker-engine&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A la práctica, la única diferencia que observarás es al comprobar la versión del paquete, que será &lt;code&gt;1.12.5&lt;/code&gt; en un caso y &lt;code&gt;17.04.0-ce&lt;/code&gt; en otro.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Contenedores y volúmenes de datos en el host</title>
      <link>https://onthedock.github.io/post/contenedores-y-volumenes-en-el-host/</link>
      <pubDate>Sat, 08 Apr 2017 05:53:59 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/contenedores-y-volumenes-en-el-host/</guid>
      <description>&lt;p&gt;Ayer leía el artículo &lt;a href=&#34;https://thenewstack.io/containers-storage-arent-yet/&#34;&gt;Containers and Storage: Why We Aren’t There Yet&lt;/a&gt; y recordaba los &lt;em&gt;quebraderos de cabeza&lt;/em&gt; que tuve intentado crear una serie de contenedores accediendo a un volumen de datos.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;El problema, como bien indica el artículo, es que &lt;em&gt;a día de hoy&lt;/em&gt;, no es posible hacer que el acceso a un volumen de datos sea a la vez &lt;strong&gt;&lt;em&gt;portable&lt;/em&gt; y &lt;em&gt;seguro&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Los detalles son muy técnicos, pero revelan la manera en la que trabajan Linux y Docker. Tener claros estos conceptos es interesante para enteneder cómo funciona Docker y cómo afrontar los problemas que puedan surgir creando contenedores.&lt;/p&gt;

&lt;p&gt;Dentro de un contenedor, por defecto, sólo tenemos el usuario &lt;code&gt;root&lt;/code&gt;, por lo que todos los procesos &lt;strong&gt;dentro&lt;/strong&gt; del contenedor se ejecutan con permisos de &lt;em&gt;superadministrador&lt;/em&gt; (&lt;code&gt;root&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, ejecutar procesos con permisos de &lt;code&gt;root&lt;/code&gt; si no es necesario, es una mala práctica; en caso de que el sistema se vea comprometido, un atacante dispondría de todos los permisos y podría causar mucho daño.&lt;/p&gt;

&lt;p&gt;En Docker, este riesgo se encuentra &lt;em&gt;aislado&lt;/em&gt; &lt;strong&gt;dentro&lt;/strong&gt; del contenedor. Pese a todo, se recomienda cambiar a un usuario con menos privilegios siempre que sea posible.&lt;/p&gt;

&lt;p&gt;Si le echas un vistazo a la &lt;a href=&#34;https://github.com/nginxinc/docker-nginx/blob/0c7611139f2ce7c5a6b1febbfd5b436c8c7d2d53/mainline/alpine/nginx.conf&#34;&gt;configuración del contenedor oficial de Nginx&lt;/a&gt; verás que la primera instrucción es:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user nginx;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es decir, que lo primero que hace Nginx es cambiar a un usuario &lt;em&gt;no-root&lt;/em&gt; cuando se ejecuta.&lt;/p&gt;

&lt;p&gt;El proceso es el siguiente: el contenedor arranca con el usuario &lt;code&gt;root&lt;/code&gt; y cuando se lanza el proceso &lt;code&gt;nginx&lt;/code&gt;, se cambia al usuario &lt;em&gt;nginx&lt;/em&gt; (eliminando los privilegios del usuario &lt;em&gt;root&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, si alguien compromete el contenedor, el proceso se ejecuta con un usuario con permisos restringidos, por lo que el atacante puede causar &lt;strong&gt;daño limitado&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So far, so good&lt;/em&gt; (hasta aquí todo bien, que dicen los anglosajones).&lt;/p&gt;

&lt;p&gt;¿Qué pasa cuando se &lt;em&gt;monta&lt;/em&gt; una carpeta una carpeta del &lt;em&gt;host&lt;/em&gt; en el contenedor?&lt;/p&gt;

&lt;p&gt;En caso de que el contenedor se vea comprometido, el atacante ya no está restringido al contenedor, sino que tiene una &lt;em&gt;vía de entrada&lt;/em&gt; al &lt;em&gt;host&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A día de hoy Docker requiere permisos de &lt;code&gt;root&lt;/code&gt; en el &lt;em&gt;host&lt;/em&gt; para ejecutarse. En particular, en el caso del &lt;em&gt;montaje&lt;/em&gt; de carpetas del &lt;em&gt;host&lt;/em&gt; en el contenedor, Docker puede montar &lt;strong&gt;cualquier&lt;/strong&gt; carpeta (o fichero) en un contenedor (mira la sección &lt;a href=&#34;https://docs.docker.com/engine/security/security/&#34;&gt;Docker deamon attack surface&lt;/a&gt; en la documentación oficial de Docker). Así que si un atacante se hiciera con el control del proceso Docker, podría lanzar un contenedor, montar la carpeta &lt;code&gt;/&lt;/code&gt; y modificar el sistema desde el contenedor.&lt;/p&gt;

&lt;p&gt;Esto sería &lt;strong&gt;muy malo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Pero ya hemos dicho antes que podemos minimizar el riesgo usando usuarios no privilegiados dentro del contenedor, como &lt;code&gt;nginx&lt;/code&gt;, ¿no?&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, siguiendo las buenas prácticas, en cuanto lancemos el proceso dentro del contenedor, cambiamos a un usuario sin privilegios y ¡problema resuelto!&lt;/p&gt;

&lt;p&gt;Ojalá las cosas fueran tan sencillas&amp;hellip;&lt;/p&gt;

&lt;p&gt;Considera el siguiente caso; hemos creado una imagen con Dokuwiki, por ejemplo, usando como base la imagen de Nginx siguiendo las buenas prácticas de seguridad. Hemos minimizado el riesgo ante un eventual ataque usando un usuario sin privilegios llamado &lt;em&gt;nginx&lt;/em&gt;. Como estamos muy orgullosos de nuestra imagen, la subimos a DockerHub: &lt;code&gt;xaviaznar/nginx-dokuwiki-seguro&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Un usuario se descarga esta imagen y lanza un contenedor, montando una carpeta local de su &lt;em&gt;host&lt;/em&gt; desde la que quiere servir su propia wiki. Para ello lanza un comando como:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -d --name miwiki -p 80:80 -v /wiki:/dokuwiki/data/pages xaviaznar/nginx-dokuwiki-seguro 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Es sólo un ejemplo ilustrativo, este &lt;em&gt;montaje&lt;/em&gt; de &lt;a href=&#34;https://www.dokuwiki.org/devel:dirlayout&#34;&gt;carpetas&lt;/a&gt; no es una buena idea).&lt;/p&gt;

&lt;p&gt;El contenedor arranca sin problemas, pero cuando quiere crear o modificar una página en el wiki, no funciona.&lt;/p&gt;

&lt;p&gt;¿Qué pasa?&lt;/p&gt;

&lt;p&gt;El problema es que ahora estamos relacionando &lt;strong&gt;dos&lt;/strong&gt; sistemas Linux, con usuarios diferentes.&lt;/p&gt;

&lt;p&gt;Por un lado tenemos el usuario &lt;code&gt;nginx&lt;/code&gt; dentro del contenedor, sin privilegios, que hemos creado siguiendo las buenas prácticas de seguridad.&lt;/p&gt;

&lt;p&gt;En el sistema &lt;em&gt;host&lt;/em&gt;, Docker se ejecuta con permisos de &lt;code&gt;root&lt;/code&gt;, por lo que puede realizar el montaje de la carpeta &lt;code&gt;/wiki&lt;/code&gt; en el contenedor sin problemas.&lt;/p&gt;

&lt;p&gt;Cuando el usuario &lt;code&gt;nginx&lt;/code&gt; (del contenedor) intenta escribir en la carpeta del &lt;em&gt;host&lt;/em&gt;, el sistema comprueba si el usuario &lt;code&gt;nginx&lt;/code&gt; tiene permisos para escribir en esa carpeta. Como el usuario &lt;code&gt;nginx&lt;/code&gt; solo existe &lt;strong&gt;dentro&lt;/strong&gt; del contenedor, el sistema del &lt;em&gt;host&lt;/em&gt; no lo reconoce y se le deniega el acceso.&lt;/p&gt;

&lt;p&gt;Aquí es donde surge el dilema entre seguridad y portabilidad: si ejecutamos los procesos en el contenedor como &lt;code&gt;root&lt;/code&gt;, no tenemos problemas para acceder a carpetas locales en el &lt;em&gt;host&lt;/em&gt;, pero nos enfrentamos a un problema de seguridad potencialmente grave. Si minimizamos el riesgo usando un usuario sin privilegios, tenemos problemas de permisos al intentar acceder a carpetas locales.&lt;/p&gt;

&lt;p&gt;Como indica &lt;a href=&#34;https://twitter.com/jejb_&#34;&gt;James Bottomley&lt;/a&gt;, evangelista de contendores para IBM en la &lt;a href=&#34;http://events.linuxfoundation.org/events/vault&#34;&gt;conferencia Vault&lt;/a&gt; sobre almacenamiento de la Linux Foundation en Boston el mes pasado:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;This is a significant problem for running unprivileged containers alongside standard images. If we’ve all written out container images for different values of root, it’ll be a horrible nasty mess somewhere.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Este es un problema significativo de cara a ejecutar contenedores sin privilegios junto a imágenes estándar. Si hemos creado imágenes de contenedores para diferentes valores de &lt;code&gt;root&lt;/code&gt;, en algún sitio habrá un lío tremendo.&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El artículo comenta algunas soluciones que se están desarrollando para solventar el problema, pero por ahora, el dilema entre seguridad y el acceso al &lt;em&gt;host&lt;/em&gt; sigue estando sobre la mesa.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>