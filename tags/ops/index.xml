<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ops on On The Dock</title>
    <link>https://onthedock.github.io/tags/ops/index.xml</link>
    <description>Recent content in Ops on On The Dock</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <atom:link href="https://onthedock.github.io/tags/ops/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Troubleshooting Kubernetes (I)</title>
      <link>https://onthedock.github.io/post/170430-troubleshooting-kubernetes-i/</link>
      <pubDate>Sun, 30 Apr 2017 15:24:35 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170430-troubleshooting-kubernetes-i/</guid>
      <description>&lt;p&gt;Tras la alegría inicial pensando que la configuración de &lt;em&gt;rsyslog&lt;/em&gt; era la causante de los cuelgues de las dos RPi 3 (&lt;a href=&#34;https://onthedock.github.io/post/170430-k3-colgado-de-nuevo/&#34;&gt;El nodo k3 del clúster colgado de nuevo&lt;/a&gt;), pasadas unas horas los dos nodos &lt;strong&gt;k2&lt;/strong&gt; y &lt;strong&gt;k3&lt;/strong&gt; han dejado de responder de nuevo.&lt;/p&gt;

&lt;p&gt;Así que es el momento de atacar el problema de forma algo más sistemática. Para ello seguiré las instrucciones que proporcina la página de Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster/&#34;&gt;Troubleshooting Clusters&lt;/a&gt;.
&lt;/p&gt;

&lt;h2 id=&#34;descripción-del-problema&#34;&gt;Descripción del problema&lt;/h2&gt;

&lt;p&gt;Tras unas horas activos y formando parte del clúster, los dos nodos que corren sobre Raspberry Pi 3 dejan de responder y el clúster los muestra como &lt;em&gt;NotReady&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El clúster está formado por tres Raspberry Pi; el nodo &lt;em&gt;master&lt;/em&gt; es una Raspberry Pi 2 B mientras que los dos nodos &lt;em&gt;worker&lt;/em&gt; son Raspberry Pi 3 B.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get nodes -o wide
NAME      STATUS     AGE       VERSION   EXTERNAL-IP   OS-IMAGE                        KERNEL-VERSION
k1        Ready      19d       v1.6.2    &amp;lt;none&amp;gt;        Raspbian GNU/Linux 8 (jessie)   4.4.50-hypriotos-v7+
k2        NotReady   15d       v1.6.2    &amp;lt;none&amp;gt;        Raspbian GNU/Linux 8 (jessie)   4.4.50-hypriotos-v7+
k3        NotReady   14d       v1.6.2    &amp;lt;none&amp;gt;        Raspbian GNU/Linux 8 (jessie)   4.4.50-hypriotos-v7+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ping&#34;&gt;Ping&lt;/h2&gt;

&lt;h3 id=&#34;ping-al-nombre-del-nodo&#34;&gt;Ping al nombre del nodo&lt;/h3&gt;

&lt;p&gt;La prueba más sencilla para ver si los nodos están colgados, es lanzar un ping desde el portátil:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ping -c5 k2.local
ping: cannot resolve k2.local: Unknown host
$ ping -c5 k3.local
ping: cannot resolve k3.local: Unknown host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En esta prueba vemos que ninguno de los nodos responde al nombre que &lt;em&gt;publica&lt;/em&gt; el servicio &lt;a href=&#34;https://en.wikipedia.org/wiki/Avahi_(software)&#34;&gt;Avahi&lt;/a&gt; en el sistema.&lt;/p&gt;

&lt;h3 id=&#34;ping-a-la-ip-del-nodo&#34;&gt;Ping a la IP del nodo&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ping -c5 192.168.1.12
PING 192.168.1.12 (192.168.1.12): 56 data bytes
64 bytes from 192.168.1.12: icmp_seq=0 ttl=64 time=3.842 ms
64 bytes from 192.168.1.12: icmp_seq=1 ttl=64 time=6.678 ms
64 bytes from 192.168.1.12: icmp_seq=2 ttl=64 time=10.789 ms
64 bytes from 192.168.1.12: icmp_seq=3 ttl=64 time=7.411 ms
64 bytes from 192.168.1.12: icmp_seq=4 ttl=64 time=10.518 ms

--- 192.168.1.12 ping statistics ---
5 packets transmitted, 5 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 3.842/7.848/10.789/2.584 ms
$ ping -c5 192.168.1.13
PING 192.168.1.13 (192.168.1.13): 56 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
Request timeout for icmp_seq 2
Request timeout for icmp_seq 3

--- 192.168.1.13 ping statistics ---
5 packets transmitted, 0 packets received, 100.0% packet loss
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso, el nodo &lt;strong&gt;k2&lt;/strong&gt; sí que responde a ping a la IP, mientras que el nodo &lt;strong&gt;k3&lt;/strong&gt; actúa como si estuviera apagado o con la red deshabilitada.&lt;/p&gt;

&lt;h3 id=&#34;ssh&#34;&gt;SSH&lt;/h3&gt;

&lt;p&gt;Aunque el nodo &lt;strong&gt;k2&lt;/strong&gt; responde a ping, no es posible conectar vía SSH; el intento de conectar no tiene éxito, pero tampoco falla (por &lt;em&gt;timeout&lt;/em&gt;, por ejemplo). He probado a conectar tanto desde el portátil como desde el nodo &lt;strong&gt;k1&lt;/strong&gt;, con el mismo resulado:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ssh pirate@192.168.1.12

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;kubelet-describe-node&#34;&gt;kubelet describe node&lt;/h2&gt;

&lt;p&gt;Usamos el comando &lt;code&gt;kubelet describe node&lt;/code&gt; para los dos nodos colgados.&lt;/p&gt;

&lt;h3 id=&#34;nodo-k2&#34;&gt;Nodo &lt;strong&gt;k2&lt;/strong&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl describe node k2
Name:			k2
Role:
Labels:			beta.kubernetes.io/arch=arm
			beta.kubernetes.io/os=linux
			kubernetes.io/hostname=k2
Annotations:		node.alpha.kubernetes.io/ttl=0
			volumes.kubernetes.io/controller-managed-attach-detach=true
Taints:			&amp;lt;none&amp;gt;
CreationTimestamp:	Sat, 15 Apr 2017 10:25:31 +0000
Phase:
Conditions:
  Type			Status		LastHeartbeatTime			LastTransitionTime			Reason			Message
  ----			------		-----------------			------------------			------			-------
  OutOfDisk 		Unknown 	Sun, 30 Apr 2017 11:56:26 +0000 	Sun, 30 Apr 2017 11:57:11 +0000 	NodeStatusUnknown 	Kubelet stopped posting node status.
  MemoryPressure 	Unknown 	Sun, 30 Apr 2017 11:56:26 +0000 	Sun, 30 Apr 2017 11:57:11 +0000 	NodeStatusUnknown 	Kubelet stopped posting node status.
  DiskPressure 		Unknown 	Sun, 30 Apr 2017 11:56:26 +0000 	Sun, 30 Apr 2017 11:57:11 +0000 	NodeStatusUnknown 	Kubelet stopped posting node status.
  Ready 		Unknown 	Sun, 30 Apr 2017 11:56:26 +0000 	Sun, 30 Apr 2017 11:57:11 +0000 	NodeStatusUnknown 	Kubelet stopped posting node status.
Addresses:		192.168.1.12,192.168.1.12,k2
Capacity:
 cpu:		4
 memory:	882632Ki
 pods:		110
Allocatable:
 cpu:		4
 memory:	780232Ki
 pods:		110
System Info:
 Machine ID:			9989a26f06984d6dbadc01770f018e3b
 System UUID:			9989a26f06984d6dbadc01770f018e3b
 Boot ID:			84bf8a2b-b83f-445b-a4b3-250dc6e5db40
 Kernel Version:		4.4.50-hypriotos-v7+
 OS Image:			Raspbian GNU/Linux 8 (jessie)
 Operating System:		linux
 Architecture:			arm
 Container Runtime Version:	docker://Unknown
 Kubelet Version:		v1.6.2
 Kube-Proxy Version:		v1.6.2
PodCIDR:			10.244.2.0/24
ExternalID:			k2
Non-terminated Pods:		(2 in total)
  Namespace			Name				CPU Requests	CPU Limits	Memory Requests	Memory Limits
  ---------			----				------------	----------	---------------	-------------
  kube-system			kube-proxy-g580s		0 (0%)		0 (0%)		0 (0%)		0 (0%)
  kube-system			weave-net-kxpk6			20m (0%)	0 (0%)		0 (0%)		0 (0%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests	CPU Limits	Memory Requests	Memory Limits
  ------------	----------	---------------	-------------
  20m (0%)	0 (0%)		0 (0%)		0 (0%)
Events:		&amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nodo-k3&#34;&gt;Nodo &lt;strong&gt;k3&lt;/strong&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl describe node k3
Name:			k3
Role:
Labels:			beta.kubernetes.io/arch=arm
			beta.kubernetes.io/os=linux
			kubernetes.io/hostname=k3
Annotations:		node.alpha.kubernetes.io/ttl=0
			volumes.kubernetes.io/controller-managed-attach-detach=true
Taints:			&amp;lt;none&amp;gt;
CreationTimestamp:	Sat, 15 Apr 2017 14:10:06 +0000
Phase:
Conditions:
  Type			Status		LastHeartbeatTime			LastTransitionTime			Reason			Message
  ----			------		-----------------			------------------			------			-------
  OutOfDisk 		Unknown 	Sun, 30 Apr 2017 10:33:45 +0000 	Sun, 30 Apr 2017 10:34:28 +0000 	NodeStatusUnknown 	Kubelet stopped posting node status.
  MemoryPressure 	Unknown 	Sun, 30 Apr 2017 10:33:45 +0000 	Sun, 30 Apr 2017 10:34:28 +0000 	NodeStatusUnknown 	Kubelet stopped posting node status.
  DiskPressure 		Unknown 	Sun, 30 Apr 2017 10:33:45 +0000 	Sun, 30 Apr 2017 10:34:28 +0000 	NodeStatusUnknown 	Kubelet stopped posting node status.
  Ready 		Unknown 	Sun, 30 Apr 2017 10:33:45 +0000 	Sun, 30 Apr 2017 10:34:28 +0000 	NodeStatusUnknown 	Kubelet stopped posting node status.
Addresses:		192.168.1.13,192.168.1.13,k3
Capacity:
 cpu:		4
 memory:	882632Ki
 pods:		110
Allocatable:
 cpu:		4
 memory:	780232Ki
 pods:		110
System Info:
 Machine ID:			9989a26f06984d6dbadc01770f018e3b
 System UUID:			9989a26f06984d6dbadc01770f018e3b
 Boot ID:			23bf96e4-ec65-489c-be00-d0fa848265f3
 Kernel Version:		4.4.50-hypriotos-v7+
 OS Image:			Raspbian GNU/Linux 8 (jessie)
 Operating System:		linux
 Architecture:			arm
 Container Runtime Version:	docker://Unknown
 Kubelet Version:		v1.6.2
 Kube-Proxy Version:		v1.6.2
PodCIDR:			10.244.3.0/24
ExternalID:			k3
Non-terminated Pods:		(2 in total)
  Namespace			Name				CPU Requests	CPU Limits	Memory Requests	Memory Limits
  ---------			----				------------	----------	---------------	-------------
  kube-system			kube-proxy-bkl4g		0 (0%)		0 (0%)		0 (0%)		0 (0%)
  kube-system			weave-net-3bf40			20m (0%)	0 (0%)		0 (0%)		0 (0%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests	CPU Limits	Memory Requests	Memory Limits
  ------------	----------	---------------	-------------
  20m (0%)	0 (0%)		0 (0%)		0 (0%)
Events:		&amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El nodo &lt;strong&gt;k2&lt;/strong&gt; deja de responder a las 11:56:26, mientras que el &lt;strong&gt;k3&lt;/strong&gt; lo hace a las 10:33:45.&lt;/p&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Cuando reinicie los dos nodos lo haré a la misma hora, para comprobar si hay diferencias en el tiempo que tarda en dejar de responder cada nodo.&lt;/li&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Actualizar la zona horaria de las Raspberry Pi.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nodo-k1-ready&#34;&gt;Nodo &lt;strong&gt;k1&lt;/strong&gt; (&lt;code&gt;Ready&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;Como referencia, incluimos el mismo comando para el nodo &lt;em&gt;master&lt;/em&gt; &lt;strong&gt;k1&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl describe node k1
Name:			k1
Role:
Labels:			beta.kubernetes.io/arch=arm
			beta.kubernetes.io/os=linux
			kubernetes.io/hostname=k1
			node-role.kubernetes.io/master=
Annotations:		node.alpha.kubernetes.io/ttl=0
			volumes.kubernetes.io/controller-managed-attach-detach=true
Taints:			node-role.kubernetes.io/master:NoSchedule
CreationTimestamp:	Mon, 10 Apr 2017 20:22:32 +0000
Phase:
Conditions:
  Type			Status	LastHeartbeatTime			LastTransitionTime			Reason				Message
  ----			------	-----------------			------------------			------				-------
  OutOfDisk 		False 	Sun, 30 Apr 2017 14:01:10 +0000 	Sun, 30 Apr 2017 06:37:10 +0000 	KubeletHasSufficientDisk 	kubelet has sufficient disk space available
  MemoryPressure 	False 	Sun, 30 Apr 2017 14:01:10 +0000 	Sun, 30 Apr 2017 06:37:10 +0000 	KubeletHasSufficientMemory 	kubelet has sufficient memory available
  DiskPressure 		False 	Sun, 30 Apr 2017 14:01:10 +0000 	Sun, 30 Apr 2017 06:37:10 +0000 	KubeletHasNoDiskPressure 	kubelet has no disk pressure
  Ready 		True 	Sun, 30 Apr 2017 14:01:10 +0000 	Sun, 30 Apr 2017 06:37:20 +0000 	KubeletReady 			kubelet is posting ready status
Addresses:		192.168.1.11,192.168.1.11,k1
Capacity:
 cpu:		4
 memory:	882632Ki
 pods:		110
Allocatable:
 cpu:		4
 memory:	780232Ki
 pods:		110
System Info:
 Machine ID:			9989a26f06984d6dbadc01770f018e3b
 System UUID:			9989a26f06984d6dbadc01770f018e3b
 Boot ID:			55e1fad0-d40c-480b-b039-5586ff728d2c
 Kernel Version:		4.4.50-hypriotos-v7+
 OS Image:			Raspbian GNU/Linux 8 (jessie)
 Operating System:		linux
 Architecture:			arm
 Container Runtime Version:	docker://Unknown
 Kubelet Version:		v1.6.2
 Kube-Proxy Version:		v1.6.2
PodCIDR:			10.244.0.0/24
ExternalID:			k1
Non-terminated Pods:		(7 in total)
  Namespace			Name					CPU Requests	CPU Limits	Memory Requests	Memory Limits
  ---------			----					------------	----------	---------------	-------------
  kube-system			etcd-k1					0 (0%)		0 (0%)		0 (0%)		0 (0%)
  kube-system			kube-apiserver-k1			250m (6%)	0 (0%)		0 (0%)		0 (0%)
  kube-system			kube-controller-manager-k1		200m (5%)	0 (0%)		0 (0%)		0 (0%)
  kube-system			kube-dns-279829092-1b27r		260m (6%)	0 (0%)		110Mi (14%)	170Mi (22%)
  kube-system			kube-proxy-3dggd			0 (0%)		0 (0%)		0 (0%)		0 (0%)
  kube-system			kube-scheduler-k1			100m (2%)	0 (0%)		0 (0%)		0 (0%)
  kube-system			weave-net-6qr0l				20m (0%)	0 (0%)		0 (0%)		0 (0%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests	CPU Limits	Memory Requests	Memory Limits
  ------------	----------	---------------	-------------
  830m (20%)	0 (0%)		110Mi (14%)	170Mi (22%)
Events:		&amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;revisando-los-logs-en-el-nodo-master&#34;&gt;Revisando los logs en el nodo &lt;em&gt;master&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;En la guía de &lt;em&gt;Troubleshooting&lt;/em&gt; de Kubernetes, el siguiente paso es revisar los logs. En el caso del nodo &lt;em&gt;master&lt;/em&gt;, los logs relevantes se encuentran en:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/var/log/kube-apiserver.log&lt;/code&gt; - El &lt;em&gt;API Server&lt;/em&gt;, encargado de servir la API&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var/log/kube-scheduler.log&lt;/code&gt; - El &lt;em&gt;Scheduler&lt;/em&gt;, encargado de las decisiones de planificar los &lt;em&gt;pods&lt;/em&gt; en los nodos&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var/log/kube-controller-manager.log&lt;/code&gt; - El responsable de gestionar los &lt;em&gt;replication controllers&lt;/em&gt; encargados de mantener el &lt;strong&gt;estado deseado&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sin embargo, los logs indicados &lt;strong&gt;no existen en la ruta indicada&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ls /var/log/kube*
ls: cannot access /var/log/kube*: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es probable que la documentación no esté actualizada, así que continuaré en cuanto encuentre los logs para poder revisarlos.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>La instalación de Kubernetes falla en Debian Jessie (Missing cgroups: memory)</title>
      <link>https://onthedock.github.io/post/170417-instalacion-de-kubernetes-falla-missing-cgroups-memory/</link>
      <pubDate>Mon, 17 Apr 2017 19:38:11 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170417-instalacion-de-kubernetes-falla-missing-cgroups-memory/</guid>
      <description>&lt;p&gt;La instalación de Kubernetes se realiza de forma casi automática gracias al &lt;em&gt;script&lt;/em&gt; &lt;code&gt;kubeadm&lt;/code&gt;. Sólo hay que seguir las instrucciones de &lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;Installing Kubernetes on Linux with kubeadm&lt;/a&gt; y la salida por pantalla del propio &lt;em&gt;script&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Para no &lt;em&gt;deshacer&lt;/em&gt; la instalación de Kubernetes sobre Raspberry Pi, he creado una máquina virtual con Debian 3 (&lt;em&gt;Jessie&lt;/em&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# uname -a
Linux k8s 3.16.0-4-amd64 #1 SMP Debian 3.16.39-1+deb8u2 (2017-03-07) x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En primer lugar, me he convertido en &lt;code&gt;root&lt;/code&gt; mediante &lt;code&gt;su -&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Uno de los requisitos para instalar Kubernetes es tener Docker instalado. En mi caso, tengo instalado &lt;code&gt;docker-engine&lt;/code&gt;, el paquete de Docker mantenido por Docker Inc. Este paquete y &lt;code&gt;docker.io&lt;/code&gt; (el mantenido por Ubuntu) son equivalentes, aunque tienen numeración de versión diferente.&lt;/p&gt;

&lt;p&gt;Verifico que Docker está instalado:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# docker version
Client:
 Version:      17.04.0-ce
 API version:  1.28
 Go version:   go1.7.5
 Git commit:   4845c56
 Built:        Mon Apr  3 17:45:49 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.04.0-ce
 API version:  1.28 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   4845c56
 Built:        Mon Apr  3 17:45:49 2017
 OS/Arch:      linux/amd64
 Experimental: false
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Antes de empezar la instalación, he actualizado el sistema mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get update &amp;amp;&amp;amp; apt-get upgrade
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A partir de aquí, sigo las instrucciones de la guía oficial.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https
...
Reading state information... Done
apt-transport-https is already the newest version.
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obtenemos la clave GPG de los paquetes de Kubernetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Añadimos el repositorio de Kubernetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list
deb http://apt.kubernetes.io/ kubernetes-xenial main
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y ya sólo nos queda actualizar la información e instalar los componentes de Kubernetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get update
...
Fetched 22.1 kB in 3s (6,784 B/s)
Reading package lists... Done
#
# apt-get install -y kubelet kubeadm kubectl kubernetes-cni
...
Setting up ebtables (2.0.10.4-3) ...
update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults
Setting up ethtool (1:3.16-1) ...
Setting up kubernetes-cni (0.5.1-00) ...
Setting up socat (1.7.2.4-2) ...
Setting up kubelet (1.6.1-00) ...
Setting up kubectl (1.6.1-00) ...
Setting up kubeadm (1.6.1-00) ...
Processing triggers for systemd (215-17+deb8u6) ...
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ya tenemos instalado Kubernetes en nuestro sistema.&lt;/p&gt;

&lt;p&gt;El siguiente paso es inicializar el clúster con &lt;code&gt;kubeadm init&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# kubeadm init
[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.
[init] Using Kubernetes version: v1.6.0
[init] Using Authorization mode: RBAC
[preflight] Running pre-flight checks
[preflight] The system verification failed. Printing the output from the verification:
OS: Linux
KERNEL_VERSION: 3.16.0-4-amd64
CONFIG_NAMESPACES: enabled
CONFIG_NET_NS: enabled
CONFIG_PID_NS: enabled
CONFIG_IPC_NS: enabled
CONFIG_UTS_NS: enabled
CONFIG_CGROUPS: enabled
CONFIG_CGROUP_CPUACCT: enabled
CONFIG_CGROUP_DEVICE: enabled
CONFIG_CGROUP_FREEZER: enabled
CONFIG_CGROUP_SCHED: enabled
CONFIG_CPUSETS: enabled
CONFIG_MEMCG: enabled
CONFIG_INET: enabled
CONFIG_EXT4_FS: enabled (as module)
CONFIG_PROC_FS: enabled
CONFIG_NETFILTER_XT_TARGET_REDIRECT: enabled (as module)
CONFIG_NETFILTER_XT_MATCH_COMMENT: enabled (as module)
CONFIG_OVERLAYFS_FS: not set - Required for overlayfs.
CONFIG_AUFS_FS: enabled (as module)
CONFIG_BLK_DEV_DM: enabled (as module)
CGROUPS_CPU: enabled
CGROUPS_CPUACCT: enabled
CGROUPS_CPUSET: enabled
CGROUPS_DEVICES: enabled
CGROUPS_FREEZER: enabled
CGROUPS_MEMORY: missing
DOCKER_VERSION: 17.04.0-ce
[preflight] WARNING: docker version is greater than the most recently validated version. Docker version: 17.04.0-ce. Max validated version: 1.12
[preflight] WARNING: hostname &amp;quot;k8s&amp;quot; could not be reached
[preflight] WARNING: hostname &amp;quot;k8s&amp;quot; lookup k8s on 80.58.61.254:53: no such host
[preflight] Some fatal errors occurred:
	missing cgroups: memory
[preflight] If you know what you are doing, you can skip pre-flight checks with `--skip-preflight-checks`
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La instalación de Kubernetes falla porque no están habilitados los &lt;em&gt;cgroups&lt;/em&gt; para la memoria. :(&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker-engine vs Docker.io</title>
      <link>https://onthedock.github.io/post/170410-docker-engine_vs_docker.io/</link>
      <pubDate>Mon, 10 Apr 2017 21:30:31 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170410-docker-engine_vs_docker.io/</guid>
      <description>&lt;p&gt;En función de la distribución que uses, verás que el paquete de instalación de Docker es &lt;code&gt;docker-engine&lt;/code&gt; o &lt;code&gt;docker.io&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;¿Cuál es la diferencia entre uno y otro?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;En la guía de instalación de Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;Installing Kubernetes on Linux with kubeadm&lt;/a&gt; se indica que para instalar Docker, el comando a usar en Ubuntu o HypriotOS es mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get install -y docker.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sin embargo, cuando he lanzado el comando en HypriotOS me ha llamado la atención el aviso &lt;code&gt;The following packages will be REMOVED: docker-engine&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ apt-get install -y docker.io
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following package was automatically installed and is no longer required:
  libltdl7
Use &#39;apt-get autoremove&#39; to remove it.
Suggested packages:
  btrfs-tools debootstrap lxc rinse
The following packages will be REMOVED:
  docker-engine
The following NEW packages will be installed:
  docker.iol
0 upgraded, 1 newy installed, 1 to remove and 0 not upgraded.
Need to get 3,082 kB of archives.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Así que me ha surgido la duda: ¿qué diferencia hay entre &lt;code&gt;docker-engine&lt;/code&gt; y &lt;code&gt;docker.io&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;La respuesta, de la mano de &lt;a href=&#34;https://www.quora.com/What-is-the-difference-between-docker-engine-and-docker-io-packages&#34;&gt;Quora&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker.io&lt;/code&gt; es mantenido por Ubuntu&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-engine&lt;/code&gt; es mantenido por Docker&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker.io&lt;/code&gt; era el antiguo dominio para el Proyecto Docker (ahora &lt;code&gt;docker.com&lt;/code&gt;). Como ya existía un paquete llamado &lt;code&gt;docker&lt;/code&gt; en los repositorios, desde Ubuntu decidieron usar el nombre &lt;code&gt;docker.io&lt;/code&gt; como nombre del paquete del Proyecto Docker.&lt;/p&gt;

&lt;p&gt;Por su parte, el equipo de Docker mantiene una versión propia de su producto para Ubuntu, a la que llaman &lt;code&gt;docker-engine&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Es decir, tanto &lt;code&gt;docker.io&lt;/code&gt; como &lt;code&gt;docker-engine&lt;/code&gt; son &lt;strong&gt;el mismo software&lt;/strong&gt;, pero gestionado por dos entes diferentes: Ubuntu o Docker Inc.&lt;/p&gt;

&lt;p&gt;En mi caso uso HypriotOS, una distribución creada específicamente para Raspberry Pi (plataforma ARM). Los creadores de esta distribución han optado por la versión mantenida por Docker, así que seguiré usando &lt;code&gt;docker-engine&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A la práctica, la única diferencia que observarás es al comprobar la versión del paquete, que será &lt;code&gt;1.12.5&lt;/code&gt; en un caso y &lt;code&gt;17.04.0-ce&lt;/code&gt; en otro.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Contenedores y volúmenes de datos en el host</title>
      <link>https://onthedock.github.io/post/170408-contenedores-y-volumenes-en-el-host/</link>
      <pubDate>Sat, 08 Apr 2017 05:53:59 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/170408-contenedores-y-volumenes-en-el-host/</guid>
      <description>&lt;p&gt;Ayer leía el artículo &lt;a href=&#34;https://thenewstack.io/containers-storage-arent-yet/&#34;&gt;Containers and Storage: Why We Aren’t There Yet&lt;/a&gt; y recordaba los &lt;em&gt;quebraderos de cabeza&lt;/em&gt; que tuve intentado crear una serie de contenedores accediendo a un volumen de datos.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;El problema, como bien indica el artículo, es que &lt;em&gt;a día de hoy&lt;/em&gt;, no es posible hacer que el acceso a un volumen de datos sea a la vez &lt;strong&gt;&lt;em&gt;portable&lt;/em&gt; y &lt;em&gt;seguro&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Los detalles son muy técnicos, pero revelan la manera en la que trabajan Linux y Docker. Tener claros estos conceptos es interesante para enteneder cómo funciona Docker y cómo afrontar los problemas que puedan surgir creando contenedores.&lt;/p&gt;

&lt;p&gt;Dentro de un contenedor, por defecto, sólo tenemos el usuario &lt;code&gt;root&lt;/code&gt;, por lo que todos los procesos &lt;strong&gt;dentro&lt;/strong&gt; del contenedor se ejecutan con permisos de &lt;em&gt;superadministrador&lt;/em&gt; (&lt;code&gt;root&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, ejecutar procesos con permisos de &lt;code&gt;root&lt;/code&gt; si no es necesario, es una mala práctica; en caso de que el sistema se vea comprometido, un atacante dispondría de todos los permisos y podría causar mucho daño.&lt;/p&gt;

&lt;p&gt;En Docker, este riesgo se encuentra &lt;em&gt;aislado&lt;/em&gt; &lt;strong&gt;dentro&lt;/strong&gt; del contenedor. Pese a todo, se recomienda cambiar a un usuario con menos privilegios siempre que sea posible.&lt;/p&gt;

&lt;p&gt;Si le echas un vistazo a la &lt;a href=&#34;https://github.com/nginxinc/docker-nginx/blob/0c7611139f2ce7c5a6b1febbfd5b436c8c7d2d53/mainline/alpine/nginx.conf&#34;&gt;configuración del contenedor oficial de Nginx&lt;/a&gt; verás que la primera instrucción es:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user nginx;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es decir, que lo primero que hace Nginx es cambiar a un usuario &lt;em&gt;no-root&lt;/em&gt; cuando se ejecuta.&lt;/p&gt;

&lt;p&gt;El proceso es el siguiente: el contenedor arranca con el usuario &lt;code&gt;root&lt;/code&gt; y cuando se lanza el proceso &lt;code&gt;nginx&lt;/code&gt;, se cambia al usuario &lt;em&gt;nginx&lt;/em&gt; (eliminando los privilegios del usuario &lt;em&gt;root&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, si alguien compromete el contenedor, el proceso se ejecuta con un usuario con permisos restringidos, por lo que el atacante puede causar &lt;strong&gt;daño limitado&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So far, so good&lt;/em&gt; (hasta aquí todo bien, que dicen los anglosajones).&lt;/p&gt;

&lt;p&gt;¿Qué pasa cuando se &lt;em&gt;monta&lt;/em&gt; una carpeta una carpeta del &lt;em&gt;host&lt;/em&gt; en el contenedor?&lt;/p&gt;

&lt;p&gt;En caso de que el contenedor se vea comprometido, el atacante ya no está restringido al contenedor, sino que tiene una &lt;em&gt;vía de entrada&lt;/em&gt; al &lt;em&gt;host&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A día de hoy Docker requiere permisos de &lt;code&gt;root&lt;/code&gt; en el &lt;em&gt;host&lt;/em&gt; para ejecutarse. En particular, en el caso del &lt;em&gt;montaje&lt;/em&gt; de carpetas del &lt;em&gt;host&lt;/em&gt; en el contenedor, Docker puede montar &lt;strong&gt;cualquier&lt;/strong&gt; carpeta (o fichero) en un contenedor (mira la sección &lt;a href=&#34;https://docs.docker.com/engine/security/security/&#34;&gt;Docker deamon attack surface&lt;/a&gt; en la documentación oficial de Docker). Así que si un atacante se hiciera con el control del proceso Docker, podría lanzar un contenedor, montar la carpeta &lt;code&gt;/&lt;/code&gt; y modificar el sistema desde el contenedor.&lt;/p&gt;

&lt;p&gt;Esto sería &lt;strong&gt;muy malo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Pero ya hemos dicho antes que podemos minimizar el riesgo usando usuarios no privilegiados dentro del contenedor, como &lt;code&gt;nginx&lt;/code&gt;, ¿no?&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, siguiendo las buenas prácticas, en cuanto lancemos el proceso dentro del contenedor, cambiamos a un usuario sin privilegios y ¡problema resuelto!&lt;/p&gt;

&lt;p&gt;Ojalá las cosas fueran tan sencillas&amp;hellip;&lt;/p&gt;

&lt;p&gt;Considera el siguiente caso; hemos creado una imagen con Dokuwiki, por ejemplo, usando como base la imagen de Nginx siguiendo las buenas prácticas de seguridad. Hemos minimizado el riesgo ante un eventual ataque usando un usuario sin privilegios llamado &lt;em&gt;nginx&lt;/em&gt;. Como estamos muy orgullosos de nuestra imagen, la subimos a DockerHub: &lt;code&gt;xaviaznar/nginx-dokuwiki-seguro&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Un usuario se descarga esta imagen y lanza un contenedor, montando una carpeta local de su &lt;em&gt;host&lt;/em&gt; desde la que quiere servir su propia wiki. Para ello lanza un comando como:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -d --name miwiki -p 80:80 -v /wiki:/dokuwiki/data/pages xaviaznar/nginx-dokuwiki-seguro 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Es sólo un ejemplo ilustrativo, este &lt;em&gt;montaje&lt;/em&gt; de &lt;a href=&#34;https://www.dokuwiki.org/devel:dirlayout&#34;&gt;carpetas&lt;/a&gt; no es una buena idea).&lt;/p&gt;

&lt;p&gt;El contenedor arranca sin problemas, pero cuando quiere crear o modificar una página en el wiki, no funciona.&lt;/p&gt;

&lt;p&gt;¿Qué pasa?&lt;/p&gt;

&lt;p&gt;El problema es que ahora estamos relacionando &lt;strong&gt;dos&lt;/strong&gt; sistemas Linux, con usuarios diferentes.&lt;/p&gt;

&lt;p&gt;Por un lado tenemos el usuario &lt;code&gt;nginx&lt;/code&gt; dentro del contenedor, sin privilegios, que hemos creado siguiendo las buenas prácticas de seguridad.&lt;/p&gt;

&lt;p&gt;En el sistema &lt;em&gt;host&lt;/em&gt;, Docker se ejecuta con permisos de &lt;code&gt;root&lt;/code&gt;, por lo que puede realizar el montaje de la carpeta &lt;code&gt;/wiki&lt;/code&gt; en el contenedor sin problemas.&lt;/p&gt;

&lt;p&gt;Cuando el usuario &lt;code&gt;nginx&lt;/code&gt; (del contenedor) intenta escribir en la carpeta del &lt;em&gt;host&lt;/em&gt;, el sistema comprueba si el usuario &lt;code&gt;nginx&lt;/code&gt; tiene permisos para escribir en esa carpeta. Como el usuario &lt;code&gt;nginx&lt;/code&gt; solo existe &lt;strong&gt;dentro&lt;/strong&gt; del contenedor, el sistema del &lt;em&gt;host&lt;/em&gt; no lo reconoce y se le deniega el acceso.&lt;/p&gt;

&lt;p&gt;Aquí es donde surge el dilema entre seguridad y portabilidad: si ejecutamos los procesos en el contenedor como &lt;code&gt;root&lt;/code&gt;, no tenemos problemas para acceder a carpetas locales en el &lt;em&gt;host&lt;/em&gt;, pero nos enfrentamos a un problema de seguridad potencialmente grave. Si minimizamos el riesgo usando un usuario sin privilegios, tenemos problemas de permisos al intentar acceder a carpetas locales.&lt;/p&gt;

&lt;p&gt;Como indica &lt;a href=&#34;https://twitter.com/jejb_&#34;&gt;James Bottomley&lt;/a&gt;, evangelista de contendores para IBM en la &lt;a href=&#34;http://events.linuxfoundation.org/events/vault&#34;&gt;conferencia Vault&lt;/a&gt; sobre almacenamiento de la Linux Foundation en Boston el mes pasado:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;This is a significant problem for running unprivileged containers alongside standard images. If we’ve all written out container images for different values of root, it’ll be a horrible nasty mess somewhere.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Este es un problema significativo de cara a ejecutar contenedores sin privilegios junto a imágenes estándar. Si hemos creado imágenes de contenedores para diferentes valores de &lt;code&gt;root&lt;/code&gt;, en algún sitio habrá un lío tremendo.&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El artículo comenta algunas soluciones que se están desarrollando para solventar el problema, pero por ahora, el dilema entre seguridad y el acceso al &lt;em&gt;host&lt;/em&gt; sigue estando sobre la mesa.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>