<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>On The Dock</title>
    <link>https://onthedock.github.io/index.xml</link>
    <description>Recent content on On The Dock</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Handmade with &amp;#9829; by Xavi Aznar</copyright>
    <lastBuildDate>Sat, 15 Apr 2017 16:27:30 +0200</lastBuildDate>
    <atom:link href="https://onthedock.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Cómo agregar un nodo a un cluster Kubernetes</title>
      <link>https://onthedock.github.io/post/como-agregar-un-nodo-a-un-cluster-kubernetes/</link>
      <pubDate>Sat, 15 Apr 2017 16:27:30 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/como-agregar-un-nodo-a-un-cluster-kubernetes/</guid>
      <description>&lt;p&gt;Después de realizar la instalación del nodo &lt;em&gt;master&lt;/em&gt; del clúster Kubernetes, el siguiente paso es agregar nodos adicionales al clúster. Es en estos nodos donde se van a planificar los &lt;em&gt;pods&lt;/em&gt; que realizan las funciones &lt;em&gt;productivas&lt;/em&gt; del clúster (en el nodo &lt;em&gt;master&lt;/em&gt; sólo realiza tareas de gestión del clúster).&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;cómo-agregar-un-nodo-a-un-cluster-kubernetes&#34;&gt;Cómo agregar un nodo a un cluster Kubernetes&lt;/h1&gt;

&lt;p&gt;En el nodo que vamos a añadir tenemos instalador HypriotOS (una distribución basada en Debian creada específicamente para ejecutar Docker en la Raspberry Pi).&lt;/p&gt;

&lt;p&gt;Hypriot OS tiene instalado Docker &lt;em&gt;de fábrica&lt;/em&gt; así que comprobamos la versión instalada:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker version
Client:
 Version:      17.04.0-ce
 API version:  1.28
 Go version:   go1.7.5
 Git commit:   4845c56
 Built:        Mon Apr  3 18:22:23 2017
 OS/Arch:      linux/arm

Server:
 Version:      17.04.0-ce
 API version:  1.28 (minimum version 1.12)
 Go version:   go1.7.5
 Git commit:   4845c56
 Built:        Mon Apr  3 18:22:23 2017
 OS/Arch:      linux/arm
 Experimental: false
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tareas-previas&#34;&gt;Tareas previas&lt;/h2&gt;

&lt;p&gt;La instalación de HypriotOS define como nombre del &lt;em&gt;host&lt;/em&gt; &lt;code&gt;black-pearl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lo primero que haremos será cambiar el nombre del &lt;em&gt;host&lt;/em&gt;. Para ello modificamos el fichero &lt;code&gt;/boot/device-init.yaml&lt;/code&gt; especificando el nombre elegido para el nuevo nodo. En mi caso, &lt;code&gt;k2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo nano /boot/device-init.yaml

# hostname for your HypriotOS device
hostname: k2

# optional wireless network settings
wifi:
  interfaces:
#     wlan0:
#       ssid: &amp;quot;MyNetwork&amp;quot;
#       password: &amp;quot;secret_password&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para que los cambios tenga efecto, es necesario reiniciar el equipo. Antes, sin embargo, vamos a establecer una IP fija.&lt;/p&gt;

&lt;p&gt;Creamos una copia del fichero &lt;code&gt;/etc/network/interfaces.d/eth0&lt;/code&gt; antes de editarlo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo cp /etc/network/interfaces.d/eth0 /etc/network/interfaces.d/eth0.original
$ sudo nano /etc/network/interfaces.d/eth0
allow-hotplug eth0
iface eth0 inet static
  address 192.168.1.12
  gateway 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez realizadas las modificaciones del &lt;em&gt;hostname&lt;/em&gt; y de la dirección IP, reiniciamos el &lt;em&gt;host&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;instalación-de-kubernetes-kubeadm-kubectl-y-kubelet&#34;&gt;Instalación de Kubernetes (&lt;code&gt;kubeadm&lt;/code&gt;,  &lt;code&gt;kubectl&lt;/code&gt; y &lt;code&gt;kubelet&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;Seguimos las instrucciones de la página oficial de Kubernetes: &lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;Installing Kubernetes on Linux with kubeadm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nos conectamos a la máquina vía &lt;em&gt;SSH&lt;/em&gt; y nos convertimos en &lt;code&gt;root&lt;/code&gt; mediante &lt;code&gt;sudo su -&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-https
...
apt-transport-https is already the newest version.0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El siguiente paso es obtener la clave GPG:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Añadimos el repositorio de Kubernetes y actualizamos la lista de paquetes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.list
deb http://apt.kubernetes.io/ kubernetes-xenial main
EOF
$ apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Verificamos que tenemos Docker instalado (en nuestro caso, &lt;code&gt;docker-engine&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ apt-get install -y docker-engine
...
docker-engine is already the newest version.0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora es el momento de lanzar la instalación de los diferentes componentes de Kubernets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ apt-get install -y kubelet kubeadm kubectl kubernetes-cni
...
The following extra packages will be installed:  ebtables socatThe following NEW packages will be installed:  ebtables kubeadm kubectl kubelet kubernetes-cni socat0 upgraded, 6 newly installed, 0 to remove and 0 not upgraded.Need to get 37.1 MB of archives.After this operation, 266 MB of additional disk space will be used.0% [Working]
...
Setting up kubernetes-cni (0.5.1-00) ...
Setting up socat (1.7.2.4-2) ...
Setting up kubelet (1.6.1-00) ...
Setting up kubectl (1.6.1-00) ...
Setting up kubeadm (1.6.1-00) ...
Processing triggers for systemd (215-17+deb8u6) ...
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;agregar-nodo-al-clúster&#34;&gt;Agregar nodo al clúster&lt;/h2&gt;

&lt;p&gt;Para añadir el &lt;em&gt;host&lt;/em&gt; como un nodo adicional del clúster de Kubernetes, usaremos el comando &lt;code&gt;kubeadm join --token {token} {IP-nodo-master}:puerto&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;El comando &lt;code&gt;kubeadm&lt;/code&gt; genera el token al inicializar el clúster, pero si no lo tenemos apuntado, podemos obtenerlo conectando al nodo &lt;em&gt;master&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ssh pirate@k1.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para obtener el &lt;em&gt;token&lt;/em&gt;, nos convertimos en el usuario &lt;code&gt;root&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo su -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación, obtenemos la lista de &lt;em&gt;tokens&lt;/em&gt; generados en el clúster:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubeadm token list
TOKEN                     TTL         EXPIRES   USAGES                 DESCRIPTION
5e6517.b9e07...293ff612   &amp;lt;forever&amp;gt;   &amp;lt;never&amp;gt;   authentication,signing   The default bootstrap token generated by &#39;kubeadm init&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copiamos el &lt;em&gt;token&lt;/em&gt; y cerramos la conexión con el nodo &lt;em&gt;master&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;En el &lt;em&gt;host&lt;/em&gt; que vamos a unir como nodo al clúster, ejecutamos (como &lt;code&gt;root&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubeadm join --token=5e6517.b9e07...293ff612 192.168.1.11:6443
[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.
[preflight] Running pre-flight checks
[preflight] WARNING: docker version is greater than the most recently validated version. Docker version: 17.04.0-ce. Max validated version: 1.12
[discovery] Trying to connect to API Server &amp;quot;192.168.1.11:6443&amp;quot;
[discovery] Created cluster-info discovery client, requesting info from &amp;quot;https://192.168.1.11:6443&amp;quot;
[discovery] Cluster info signature and contents are valid, will use API Server &amp;quot;https://192.168.1.11:6443&amp;quot;
[discovery] Successfully established connection with API Server &amp;quot;192.168.1.11:6443&amp;quot;
[bootstrap] Detected server version: v1.6.0
[bootstrap] The server supports the Certificates API (certificates.k8s.io/v1beta1)
[csr] Created API client to obtain unique certificate for this node, generating keys and certificate signing request
[csr] Received signed certificate from the API server, generating KubeConfig...
[kubeconfig] Wrote KubeConfig file to disk: &amp;quot;/etc/kubernetes/kubelet.conf&amp;quot;
Node join complete:
   * Certificate signing request sent to master and response  received.
   * Kubelet informed of new secure connection details.

   Run &#39;kubectl get nodes&#39; on the master to see this machine join.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;verificación&#34;&gt;Verificación&lt;/h2&gt;

&lt;p&gt;Para comprobar que el nodo &lt;code&gt;k2&lt;/code&gt; se ha añadido correctamente al clúster, nos conectamos al nodo &lt;em&gt;master&lt;/em&gt; y obtenemos la lista de nodos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get nodes
NAME       STATUS     AGE       VERSION
k1         Ready      4d        v1.6.1
k2         NotReady   40s       v1.6.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El nodo &lt;code&gt;k2&lt;/code&gt; del clúster aparece como &lt;code&gt;NotReady&lt;/code&gt;. Esta situación debe ser temporal. Tras unos instantes, al ejecutar de nuevo el comando, el &lt;em&gt;status&lt;/em&gt; del nuevo nodo debería haber cambiado y mostrarse como &lt;code&gt;Ready&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get nodes
NAME       STATUS    AGE       VERSION
k1         Ready     4d        v1.6.1
k2.local   Ready     1m        v1.6.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cambio-de-nombre-del-nodo&#34;&gt;Cambio de nombre del nodo&lt;/h2&gt;

&lt;p&gt;Incialmente he añadido el nodo al cúster como &lt;code&gt;k2.local&lt;/code&gt;, sin darme cuenta que el sufijo &lt;code&gt;.local&lt;/code&gt; lo añade el &lt;em&gt;daemon&lt;/em&gt; Avahi al publicar el nombre del &lt;em&gt;host&lt;/em&gt; en la red local.&lt;/p&gt;

&lt;p&gt;He modificado el nombre del nodo en el fichero &lt;code&gt;/boot/device-init.yaml&lt;/code&gt; y he reiniciado el nodo, pero a nivel del clúster, el nodo &lt;code&gt;k2.local&lt;/code&gt; sigue formando parte del mismo. Por eso aparece como &lt;code&gt;NotReady&lt;/code&gt; al ejecutar &lt;code&gt;get nodes&lt;/code&gt;. El &lt;em&gt;nuevo&lt;/em&gt;  nodo &lt;code&gt;k2&lt;/code&gt; sí que aparece en al ejecutar el comando &lt;code&gt;get nodes&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get nodes
NAME       STATUS     AGE       VERSION
k1         Ready      4d        v1.6.1
k2         Ready      37m       v1.6.1
k2.local   NotReady   1h        v1.6.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para evitar confusiones, lo más conveniente es eliminar el nodo del clúster mediante &lt;code&gt;kubectl delete node&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl delete node k2.local
node &amp;quot;k2.local&amp;quot; deleted
HypriotOS/armv7: pirate@k1 in ~
$ kubectl get nodes
NAME      STATUS    AGE       VERSION
k1        Ready     4d        v1.6.1
k2        Ready     45m       v1.6.1
$
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Error: The connection to the server localhost:8080 was refused</title>
      <link>https://onthedock.github.io/post/error_the-connection-to-the-server-was-refused/</link>
      <pubDate>Fri, 14 Apr 2017 18:10:34 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/error_the-connection-to-the-server-was-refused/</guid>
      <description>&lt;p&gt;Después de &lt;a href=&#34;https://onthedock.github.io/post/k8s-en-rpi-teaser/&#34;&gt;conseguir arrancar Kubernetes tras la instalación&lt;/a&gt;, al intentar ejecutar comandos vía &lt;code&gt;kubectl&lt;/code&gt; obtengo el mensaje de error &lt;code&gt;The connection to the server localhost:8080 was refused - did you specify the right host or port?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A continuación explico cómo solucionar el error y evitar que vuelva a mostrarse.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;En la guía oficial para instalar Kubernetes en Linux con &lt;code&gt;kubeadm&lt;/code&gt; &lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;Installing Kubernetes on Linux with kubeadm&lt;/a&gt;, en la salida del comando &lt;code&gt;kubeadm init&lt;/code&gt; en el punto &lt;em&gt;(&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;) - Initializing your master&lt;/em&gt;, se muestra:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Your Kubernetes master has initialized successfully!

To start using your cluster, you need to run (as a regular &amp;gt;user):

 sudo cp /etc/kubernetes/admin.conf $HOME/
 sudo chown $(id -u):$(id -g) $HOME/admin.conf
 export KUBECONFIG=$HOME/admin.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El problema es que la &lt;em&gt;exportación&lt;/em&gt; de la variable de entorno realizada mediante &lt;code&gt;export KUBECONFIG=$HOME/admin.conf&lt;/code&gt; &lt;strong&gt;se pierde en cuanto se cierra la sesión&lt;/strong&gt;.
Por tanto, cuando reconectamos más tarde, la variable &lt;code&gt;KUBECONFIG&lt;/code&gt; está vacía y el comando &lt;code&gt;kubectl&lt;/code&gt; intenta conectar con &lt;code&gt;localhost:8080&lt;/code&gt;. Como el API server no está escuchando en esta IP y puerto, lo que obtenemos el mensaje de error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The connection to the server localhost:8080 was refused - did you specify the right host or port?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si miramos el contenido del fichero &lt;code&gt;$HOME/admin.conf&lt;/code&gt; mediante &lt;code&gt;cat $HOME/admin.conf&lt;/code&gt; encontramos una línea que identifica el servidor: &lt;code&gt;server: https://192.168.1.11:6443&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Parece que lo único que tenemos que hacer es especificar el servidor como parámetro para &lt;code&gt;kubectl&lt;/code&gt;, pero&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get nodes --server=https://192.168.1.11:6443
Please enter Username: pirate
Please enter Password: ********
  Unable to connect to the server: x509: certificate signed by unknown authority
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Si usamos el usuario &lt;code&gt;root&lt;/code&gt;, el resultado es el mismo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Observando el contenido del fichero &lt;code&gt;admin.conf&lt;/code&gt; vemos que para el parámetro &lt;code&gt;user&lt;/code&gt; se especifican certificados (mediante &lt;code&gt;client-certificate-data&lt;/code&gt; y &lt;code&gt;client-key-data&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
users:
- name: kubernetes-admin
  user:
    client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM4akNDQ...
    client-key-data:   LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLQVdLN3JjWDIKY2DIKY2t1c...
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Así que no podemos autenticarnos en el API Server con los usuarios del sistema y tenemos que usar los certificados en el fichero &lt;code&gt;admin.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Esto nos lleva de nuevo a la variable &lt;code&gt;KUBECONFIG&lt;/code&gt;. Si lanzamos el comando &lt;code&gt;export KUBECONFIG...&lt;/code&gt;, los comandos funcionarán durante la sesión en curso, pero tendremos que lanzar el comando &lt;code&gt;export&lt;/code&gt; en cada nueva sesión:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ export KUBECONFIG=$HOME/admin.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La solución para que la variable se establezca automáticamente en cada inicio de sesión es añadiéndo el valor en el fichero &lt;code&gt;$HOME/.bashrc&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nano $HOME/.bashrc
export KUBECONFIG=$HOME/admin.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para verificar que funciona como debe, cierra sesión y vuelve a iniciarla.&lt;/p&gt;

&lt;p&gt;Comprueba que puedes lanzar comandos sin problemas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get nodes
NAME      STATUS    AGE       VERSION
k1        Ready     3d        v1.6.1
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¡Problema solucionado!&lt;/p&gt;

&lt;p&gt;Otra solución alternativa, si no quieres modificar el fichero &lt;code&gt;$HOME/admin.conf&lt;/code&gt; es pasar la ubicación del fichero como parámetro a &lt;code&gt;kubectl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get nodes
The connection to the server localhost:8080 was refused - did you specify the right host or port?
$ kubectl --kubeconfig ./admin.conf get nodes
NAME      STATUS    AGE       VERSION
k1        Ready     3d        v1.6.1
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Puedes usar también este método para conectar, por ejemplo, desde otro equipo al nodo master del clúster (debes copiar primero el fichero &lt;code&gt;admin.conf&lt;/code&gt; a tu equipo, desde su ubicación original &lt;code&gt;/etc/kubernetes/admin.conf&lt;/code&gt; o desde la carpeta &lt;code&gt;$HOME&lt;/code&gt; del usuario, si lo has copiado):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ scp pirate@k1.local:/home/pirate/admin.conf .
kubectl --kubeconfig ./admin.conf get nodes
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes en la Raspberry Pi (teaser)</title>
      <link>https://onthedock.github.io/post/k8s-en-rpi-teaser/</link>
      <pubDate>Mon, 10 Apr 2017 22:45:28 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/k8s-en-rpi-teaser/</guid>
      <description>&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/itsalive.jpg&#34; alt=&#34;Kubernetes en la Raspberry Pi (teaser) images/itsalive.jpg&#34; width=400 height=292 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/k8s-en-rpi.png&#34; alt=&#34;Kubernetes en la Raspberry Pi (teaser) images/k8s-en-rpi.png&#34; width=640 height=259 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
  &lt;figcaption&gt;
    
    Todos los componentes necesarios en Running
    
  &lt;/figcaption&gt;
  
&lt;/figure&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker-engine vs Docker.io</title>
      <link>https://onthedock.github.io/post/docker-engine_vs_docker.io/</link>
      <pubDate>Mon, 10 Apr 2017 21:30:31 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/docker-engine_vs_docker.io/</guid>
      <description>&lt;p&gt;En función de la distribución que uses, verás que el paquete de instalación de Docker es &lt;code&gt;docker-engine&lt;/code&gt; o &lt;code&gt;docker.io&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;¿Cuál es la diferencia entre uno y otro?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;En la guía de instalación de Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/kubeadm/&#34;&gt;Installing Kubernetes on Linux with kubeadm&lt;/a&gt; se indica que para instalar Docker, el comando a usar en Ubuntu o HypriotOS es mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt-get install -y docker.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sin embargo, cuando he lanzado el comando en HypriotOS me ha llamado la atención el aviso &lt;code&gt;The following packages will be REMOVED: docker-engine&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ apt-get install -y docker.io
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following package was automatically installed and is no longer required:
  libltdl7
Use &#39;apt-get autoremove&#39; to remove it.
Suggested packages:
  btrfs-tools debootstrap lxc rinse
The following packages will be REMOVED:
  docker-engine
The following NEW packages will be installed:
  docker.iol
0 upgraded, 1 newy installed, 1 to remove and 0 not upgraded.
Need to get 3,082 kB of archives.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Así que me ha surgido la duda: ¿qué diferencia hay entre &lt;code&gt;docker-engine&lt;/code&gt; y &lt;code&gt;docker.io&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;La respuesta, de la mano de &lt;a href=&#34;https://www.quora.com/What-is-the-difference-between-docker-engine-and-docker-io-packages&#34;&gt;Quora&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker.io&lt;/code&gt; es mantenido por Ubuntu&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-engine&lt;/code&gt; es mantenido por Docker&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker.io&lt;/code&gt; era el antiguo dominio para el Proyecto Docker (ahora &lt;code&gt;docker.com&lt;/code&gt;). Como ya existía un paquete llamado &lt;code&gt;docker&lt;/code&gt; en los repositorios, desde Ubuntu decidieron usar el nombre &lt;code&gt;docker.io&lt;/code&gt; como nombre del paquete del Proyecto Docker.&lt;/p&gt;

&lt;p&gt;Por su parte, el equipo de Docker mantiene una versión propia de su producto para Ubuntu, a la que llaman &lt;code&gt;docker-engine&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Es decir, tanto &lt;code&gt;docker.io&lt;/code&gt; como &lt;code&gt;docker-engine&lt;/code&gt; son &lt;strong&gt;el mismo software&lt;/strong&gt;, pero gestionado por dos entes diferentes: Ubuntu o Docker Inc.&lt;/p&gt;

&lt;p&gt;En mi caso uso HypriotOS, una distribución creada específicamente para Raspberry Pi (plataforma ARM). Los creadores de esta distribución han optado por la versión mantenida por Docker, así que seguiré usando &lt;code&gt;docker-engine&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A la práctica, la única diferencia que observarás es al comprobar la versión del paquete, que será &lt;code&gt;1.12.5&lt;/code&gt; en un caso y &lt;code&gt;17.04.0-ce&lt;/code&gt; en otro.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Acciones previas a la instalación de Kubernetes en Raspberry Pi</title>
      <link>https://onthedock.github.io/post/acciones-previas-instalacion-rpi/</link>
      <pubDate>Sun, 09 Apr 2017 21:34:16 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/acciones-previas-instalacion-rpi/</guid>
      <description>&lt;p&gt;Uno de los objetivos motivadores de la existencia de este blog es instalar un clúster de Kubernetes sobre Raspberry Pi. Este artículo se centra en las tareas previas a la instalación en sí.&lt;/p&gt;

&lt;p&gt;Kubernetes requiere una instalación previa de Docker, una tarea simplificada gracias a HypriotOS, la &lt;em&gt;distro&lt;/em&gt; creada específicamente con este fin.&lt;/p&gt;

&lt;p&gt;El siguiente paso, la instalación de Kubernetes en la Raspberry será objeto de otra(s) entrada(s). Pero sin duda esta tarea sería mucho más complicada sin las contribuciones del joven finlandés &lt;a href=&#34;https://www.cncf.io/blog/2016/11/29/diversity-scholarship-series-programming-journey-becoming-kubernetes-maintainer/&#34;&gt;Lucas Käldström&lt;/a&gt; y su proyecto -ahora integrado la rama principal- &lt;a href=&#34;https://github.com/luxas/kubernetes-on-arm&#34;&gt;Kubernetes on ARM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Descarga la imagen de &lt;a href=&#34;https://blog.hypriot.com/downloads/&#34;&gt;HypriotOS&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Traspásala a una tarjeta microSD usando, por ejemplo, &lt;a href=&#34;https://etcher.io/&#34;&gt;Etcher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Inserta la tarjeta microsSD en la Raspberry Pi y arranca la RPi.&lt;/li&gt;
&lt;li&gt;Comprueba que ha arrancado correctamente haciendo ping a &lt;code&gt;black-pearl.local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Accede a la RPi mediante &lt;code&gt;ssh pirate@black-pearl.local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Acepta el mensaje de seguridad (es la primera vez que conectas al equipo)&lt;/li&gt;
&lt;li&gt;Edita el fichero &lt;code&gt;/boot/device-init.yaml&lt;/code&gt; para modificar el nombre de la RPi. En mi caso, he cambiado el nombre a &lt;code&gt;k1&lt;/code&gt;: &lt;code&gt;hostname: k1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Crea un backup del fichero de configuración de la tarjeta de red: &lt;code&gt;sudo cp /etc/network/interfaces.d/eth0 /etc/network/interfaces.d/eth0.original&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Edita el fichero &lt;code&gt;/etc/network/interfaces.d/eth0&lt;/code&gt; para establecer una IP estática para la RPi:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  allow-hotplug eth0
  iface eth0 inet static
	address 192.168.1.11
	gateway 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Reinicia la RPi para que los cambios sean efectivos: &lt;code&gt;sudo reboot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Comprueba que la RPi responde a ping con el nuevo nombre: &lt;code&gt;ping k1.local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Accede a la RPi mediante &lt;code&gt;ssh pirate@k1.local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Actualiza la RPi: &lt;code&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade -y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Verifica la versión de Docker instalada: &lt;code&gt;$ docker version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Contenedores y volúmenes de datos en el host</title>
      <link>https://onthedock.github.io/post/contenedores-y-volumenes-en-el-host/</link>
      <pubDate>Sat, 08 Apr 2017 05:53:59 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/contenedores-y-volumenes-en-el-host/</guid>
      <description>&lt;p&gt;Ayer leía el artículo &lt;a href=&#34;https://thenewstack.io/containers-storage-arent-yet/&#34;&gt;Containers and Storage: Why We Aren’t There Yet&lt;/a&gt; y recordaba los &lt;em&gt;quebraderos de cabeza&lt;/em&gt; que tuve intentado crear una serie de contenedores accediendo a un volumen de datos.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;El problema, como bien indica el artículo, es que &lt;em&gt;a día de hoy&lt;/em&gt;, no es posible hacer que el acceso a un volumen de datos sea a la vez &lt;strong&gt;&lt;em&gt;portable&lt;/em&gt; y &lt;em&gt;seguro&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Los detalles son muy técnicos, pero revelan la manera en la que trabajan Linux y Docker. Tener claros estos conceptos es interesante para enteneder cómo funciona Docker y cómo afrontar los problemas que puedan surgir creando contenedores.&lt;/p&gt;

&lt;p&gt;Dentro de un contenedor, por defecto, sólo tenemos el usuario &lt;code&gt;root&lt;/code&gt;, por lo que todos los procesos &lt;strong&gt;dentro&lt;/strong&gt; del contenedor se ejecutan con permisos de &lt;em&gt;superadministrador&lt;/em&gt; (&lt;code&gt;root&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, ejecutar procesos con permisos de &lt;code&gt;root&lt;/code&gt; si no es necesario, es una mala práctica; en caso de que el sistema se vea comprometido, un atacante dispondría de todos los permisos y podría causar mucho daño.&lt;/p&gt;

&lt;p&gt;En Docker, este riesgo se encuentra &lt;em&gt;aislado&lt;/em&gt; &lt;strong&gt;dentro&lt;/strong&gt; del contenedor. Pese a todo, se recomienda cambiar a un usuario con menos privilegios siempre que sea posible.&lt;/p&gt;

&lt;p&gt;Si le echas un vistazo a la &lt;a href=&#34;https://github.com/nginxinc/docker-nginx/blob/0c7611139f2ce7c5a6b1febbfd5b436c8c7d2d53/mainline/alpine/nginx.conf&#34;&gt;configuración del contenedor oficial de Nginx&lt;/a&gt; verás que la primera instrucción es:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user nginx;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es decir, que lo primero que hace Nginx es cambiar a un usuario &lt;em&gt;no-root&lt;/em&gt; cuando se ejecuta.&lt;/p&gt;

&lt;p&gt;El proceso es el siguiente: el contenedor arranca con el usuario &lt;code&gt;root&lt;/code&gt; y cuando se lanza el proceso &lt;code&gt;nginx&lt;/code&gt;, se cambia al usuario &lt;em&gt;nginx&lt;/em&gt; (eliminando los privilegios del usuario &lt;em&gt;root&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, si alguien compromete el contenedor, el proceso se ejecuta con un usuario con permisos restringidos, por lo que el atacante puede causar &lt;strong&gt;daño limitado&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So far, so good&lt;/em&gt; (hasta aquí todo bien, que dicen los anglosajones).&lt;/p&gt;

&lt;p&gt;¿Qué pasa cuando se &lt;em&gt;monta&lt;/em&gt; una carpeta una carpeta del &lt;em&gt;host&lt;/em&gt; en el contenedor?&lt;/p&gt;

&lt;p&gt;En caso de que el contenedor se vea comprometido, el atacante ya no está restringido al contenedor, sino que tiene una &lt;em&gt;vía de entrada&lt;/em&gt; al &lt;em&gt;host&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A día de hoy Docker requiere permisos de &lt;code&gt;root&lt;/code&gt; en el &lt;em&gt;host&lt;/em&gt; para ejecutarse. En particular, en el caso del &lt;em&gt;montaje&lt;/em&gt; de carpetas del &lt;em&gt;host&lt;/em&gt; en el contenedor, Docker puede montar &lt;strong&gt;cualquier&lt;/strong&gt; carpeta (o fichero) en un contenedor (mira la sección &lt;a href=&#34;https://docs.docker.com/engine/security/security/&#34;&gt;Docker deamon attack surface&lt;/a&gt; en la documentación oficial de Docker). Así que si un atacante se hiciera con el control del proceso Docker, podría lanzar un contenedor, montar la carpeta &lt;code&gt;/&lt;/code&gt; y modificar el sistema desde el contenedor.&lt;/p&gt;

&lt;p&gt;Esto sería &lt;strong&gt;muy malo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Pero ya hemos dicho antes que podemos minimizar el riesgo usando usuarios no privilegiados dentro del contenedor, como &lt;code&gt;nginx&lt;/code&gt;, ¿no?&lt;/p&gt;

&lt;p&gt;Desde el punto de vista de la seguridad, siguiendo las buenas prácticas, en cuanto lancemos el proceso dentro del contenedor, cambiamos a un usuario sin privilegios y ¡problema resuelto!&lt;/p&gt;

&lt;p&gt;Ojalá las cosas fueran tan sencillas&amp;hellip;&lt;/p&gt;

&lt;p&gt;Considera el siguiente caso; hemos creado una imagen con Dokuwiki, por ejemplo, usando como base la imagen de Nginx siguiendo las buenas prácticas de seguridad. Hemos minimizado el riesgo ante un eventual ataque usando un usuario sin privilegios llamado &lt;em&gt;nginx&lt;/em&gt;. Como estamos muy orgullosos de nuestra imagen, la subimos a DockerHub: &lt;code&gt;xaviaznar/nginx-dokuwiki-seguro&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Un usuario se descarga esta imagen y lanza un contenedor, montando una carpeta local de su &lt;em&gt;host&lt;/em&gt; desde la que quiere servir su propia wiki. Para ello lanza un comando como:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker run -d --name miwiki -p 80:80 -v /wiki:/dokuwiki/data/pages xaviaznar/nginx-dokuwiki-seguro 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Es sólo un ejemplo ilustrativo, este &lt;em&gt;montaje&lt;/em&gt; de &lt;a href=&#34;https://www.dokuwiki.org/devel:dirlayout&#34;&gt;carpetas&lt;/a&gt; no es una buena idea).&lt;/p&gt;

&lt;p&gt;El contenedor arranca sin problemas, pero cuando quiere crear o modificar una página en el wiki, no funciona.&lt;/p&gt;

&lt;p&gt;¿Qué pasa?&lt;/p&gt;

&lt;p&gt;El problema es que ahora estamos relacionando &lt;strong&gt;dos&lt;/strong&gt; sistemas Linux, con usuarios diferentes.&lt;/p&gt;

&lt;p&gt;Por un lado tenemos el usuario &lt;code&gt;nginx&lt;/code&gt; dentro del contenedor, sin privilegios, que hemos creado siguiendo las buenas prácticas de seguridad.&lt;/p&gt;

&lt;p&gt;En el sistema &lt;em&gt;host&lt;/em&gt;, Docker se ejecuta con permisos de &lt;code&gt;root&lt;/code&gt;, por lo que puede realizar el montaje de la carpeta &lt;code&gt;/wiki&lt;/code&gt; en el contenedor sin problemas.&lt;/p&gt;

&lt;p&gt;Cuando el usuario &lt;code&gt;nginx&lt;/code&gt; (del contenedor) intenta escribir en la carpeta del &lt;em&gt;host&lt;/em&gt;, el sistema comprueba si el usuario &lt;code&gt;nginx&lt;/code&gt; tiene permisos para escribir en esa carpeta. Como el usuario &lt;code&gt;nginx&lt;/code&gt; solo existe &lt;strong&gt;dentro&lt;/strong&gt; del contenedor, el sistema del &lt;em&gt;host&lt;/em&gt; no lo reconoce y se le deniega el acceso.&lt;/p&gt;

&lt;p&gt;Aquí es donde surge el dilema entre seguridad y portabilidad: si ejecutamos los procesos en el contenedor como &lt;code&gt;root&lt;/code&gt;, no tenemos problemas para acceder a carpetas locales en el &lt;em&gt;host&lt;/em&gt;, pero nos enfrentamos a un problema de seguridad potencialmente grave. Si minimizamos el riesgo usando un usuario sin privilegios, tenemos problemas de permisos al intentar acceder a carpetas locales.&lt;/p&gt;

&lt;p&gt;Como indica &lt;a href=&#34;https://twitter.com/jejb_&#34;&gt;James Bottomley&lt;/a&gt;, evangelista de contendores para IBM en la &lt;a href=&#34;http://events.linuxfoundation.org/events/vault&#34;&gt;conferencia Vault&lt;/a&gt; sobre almacenamiento de la Linux Foundation en Boston el mes pasado:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;This is a significant problem for running unprivileged containers alongside standard images. If we’ve all written out container images for different values of root, it’ll be a horrible nasty mess somewhere.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Este es un problema significativo de cara a ejecutar contenedores sin privilegios junto a imágenes estándar. Si hemos creado imágenes de contenedores para diferentes valores de &lt;code&gt;root&lt;/code&gt;, en algún sitio habrá un lío tremendo.&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El artículo comenta algunas soluciones que se están desarrollando para solventar el problema, pero por ahora, el dilema entre seguridad y el acceso al &lt;em&gt;host&lt;/em&gt; sigue estando sobre la mesa.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Publica en Github Pages</title>
      <link>https://onthedock.github.io/post/publica-en-github-pages/</link>
      <pubDate>Mon, 03 Apr 2017 22:38:35 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/publica-en-github-pages/</guid>
      <description>&lt;p&gt;Cómo publicar el sitio web generado con Hugo en GitHub Pages.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Siguiendo las instrucciones de la página de Hugo sobre &lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/#hosting-personal-organization-pages&#34;&gt;cómo publicar en Github Pages&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creo un repo llamado &lt;code&gt;onthedock.github.io&lt;/code&gt;: este albergará el sitio público.&lt;/li&gt;
&lt;li&gt;Creo un repo llamado &lt;code&gt;onthedock-hugo&lt;/code&gt; que contendrá todo el site: ficheros de hugo, el template, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Creo una carpeta local llamada &lt;code&gt;onthedock-githubpages&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dentro de la carpeta, lanzo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git clone https://github.com/onthedock/onthedock-hugo.git`
Cloning into &#39;.&#39;...
warning: You appear to have cloned an empty repository.
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compruebo que tengo un repositorio local inicializado:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git status
On branch master

Initial commit

nothing to commit (create/copy files and use &amp;quot;git add&amp;quot; to track)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copio el contenido del &lt;em&gt;site&lt;/em&gt; de Hugo (que previamente he movido a otra carpeta):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git status
On branch master
Initial commit
Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)
	config.toml
	content/
	static/
	themes/
nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Las carpetas vacías no se añaden a Git.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eliminamos la carpeta &lt;code&gt;$HUGO/public&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Añadimos un &lt;a href=&#34;https://git-scm.com/book/es/v1/Las-herramientas-de-Git-Subm%C3%B3dulos&#34;&gt;&lt;em&gt;submodulo&lt;/em&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git submodule add -b master https://github.com/onthedock/onthedock.github.io.git public
Cloning into &#39;/Users/xavi/Dropbox/dev/hugo/onthedock-githubpages/public&#39;...
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comprobamos el estado del repositorio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git status
On branch master

Initial commit

Changes to be committed:
  (use &amp;quot;git rm --cached &amp;lt;file&amp;gt;...&amp;quot; to unstage)

	new file:   .gitmodules
	new file:   public

Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	config.toml
	content/
	static/
	themes/

$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Añadimos los ficheros del &lt;em&gt;andamiaje&lt;/em&gt; de Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git add .
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Verifico que el repositorio &lt;em&gt;remoto&lt;/em&gt; es el correcto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git remote -v
origin	https://github.com/onthedock/onthedock-hugo.git (fetch)
origin	https://github.com/onthedock/onthedock-hugo.git (push)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y subo el sitio al &lt;em&gt;repo&lt;/em&gt; remoto: &lt;code&gt;onthedock-hugo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$  git push origin master
error: src refspec master does not match any.
error: failed to push some refs to &#39;https://github.com/onthedock/onthedock-hugo.git&#39;
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oopps.&lt;/p&gt;

&lt;p&gt;El problema era que no había guardado ningún cambio, por lo que no existía la rama &lt;code&gt;master&lt;/code&gt;. Aunque he interpretado correctamente el mensaje, he corregido el problema en el extremo opuesto (en el repositorio remoto); he creado un fichero &lt;code&gt;License.md&lt;/code&gt; y he lanzado &lt;code&gt;git pull&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git pull origin
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/onthedock/onthedock-hugo
 * [new branch]      master     -&amp;gt; origin/master
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt; hace un &lt;code&gt;git fetch&lt;/code&gt; y un &lt;code&gt;git merge&lt;/code&gt;, lo que crea un &lt;em&gt;commit&lt;/em&gt; (que era lo que me faltaba por hacer):&lt;/p&gt;

&lt;p&gt;Vuelvo a intentarlo y esta vez sí:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git commit

(había añadido los cambios al _staging area_ pero no los había guardado con _commit_)

$ git push origin master
Username for &#39;https://github.com&#39;: onthedock
Password for &#39;https://onthedock@github.com&#39;:
Counting objects: 64, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (56/56), done.
Writing objects: 100% (64/64), 3.28 MiB | 547.00 KiB/s, done.
Total 64 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), done.
To https://github.com/onthedock/onthedock-hugo.git
   92f53f2..5ecc4bc  master -&amp;gt; master
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora voy a generar el sitio (después de actualizar el fichero &lt;code&gt;config.toml&lt;/code&gt; para que el parámetro &lt;code&gt;baseURL&lt;/code&gt; apunte a la dirección &lt;em&gt;pública&lt;/em&gt; del sitio en GitHub):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ hugo
Started building sites ...
Built site for language en:
0 draft content
0 future content
0 expired content
6 regular pages created
14 other pages created
0 non-page files copied
12 paginator pages created
8 tags created
2 categories created
total in 68 ms
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
  (commit or discard the untracked or modified content in submodules)

	modified:   public (untracked content)

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El contenido de la carpeta &lt;code&gt;$HUGO/public&lt;/code&gt;  está contenida en un &lt;em&gt;submódulo&lt;/em&gt; de Git.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd public/
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	404.html
	categories/
	images/
	index.html
	index.xml
	page/
	post/
	sitemap.xml
	tags/

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora, desde este &lt;em&gt;sub-repositorio&lt;/em&gt;, lanzo &lt;code&gt;git add&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git add .
$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

	new file:   404.html
	new file:   categories/dev/index.html
	new file:   categories/dev/index.xml
	new file:   categories/dev/page/1/index.html
	new file:   categories/index.html
	new file:   categories/ops/index.html
	new file:   categories/ops/index.xml
	new file:   categories/ops/page/1/index.html
.
.
.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lanzo un &lt;em&gt;commit&lt;/em&gt; para guardar los cambios:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Verifico que el repositorio remoto es &lt;code&gt;onthedock.github.io&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git remote -v
origin	https://github.com/onthedock/onthedock.github.io.git (fetch)
origin	https://github.com/onthedock/onthedock.github.io.git (push)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora, subo los cambios al repositorio de GitHub Pages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git push origin master
Username for &#39;https://github.com&#39;: onthedock
Password for &#39;https://onthedock@github.com&#39;:
Counting objects: 104, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (74/74), done.
Writing objects: 100% (104/104), 911.20 KiB | 0 bytes/s, done.
Total 104 (delta 41), reused 0 (delta 0)
remote: Resolving deltas: 100% (41/41), done.
To https://github.com/onthedock/onthedock.git
   49c08af..5432d12  master -&amp;gt; master
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La web estará accesible en los próximos diez minutos, aproximadamente, en &lt;code&gt;http://onthedock.github.io&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;El nombre del repositorio debe ser &lt;code&gt;onthedock.github.io&lt;/code&gt;, y no sólo  &lt;code&gt;onthedock&lt;/code&gt;. Si te pasa como a mi y debes cambiar el nombre del &lt;em&gt;repo&lt;/em&gt; , recuerda que ¡puedes hacerlo!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Se puede renombrar el repositorio desde GitHub, pero eso supone que también hay que actualizar el nombre del repositorio en la configuración del  &lt;em&gt;remote&lt;/em&gt; en el repositorio local.&lt;/p&gt;

&lt;p&gt;Para ello, usa el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git remote set-url origin https://github.com/onthedock/onthedock.github.io.git
$ git remote -v
origin	https://github.com/onthedock/onthedock.github.io.git (fetch)
origin	https://github.com/onthedock/onthedock.github.io.git (push)
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez cambiado el nombre del repositorio, tras una corta espera, el sitio ya es accesible a través de &lt;code&gt;https://onthedock.github.io&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Agregar nueva entrada con Hugo</title>
      <link>https://onthedock.github.io/post/agregar-nueva-entrada-con-hugo/</link>
      <pubDate>Sat, 01 Apr 2017 22:36:46 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/agregar-nueva-entrada-con-hugo/</guid>
      <description>&lt;p&gt;Cómo publicar una entrada usando Hugo, el generador de sitios estáticos, desde la creación del &lt;em&gt;site&lt;/em&gt; hasta la subida de los ficheros en el servidor web.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;algunas-consideraciones-previas&#34;&gt;Algunas consideraciones previas&lt;/h2&gt;

&lt;p&gt;En primer lugar, es importante que Hugo esté correctamente configurado. Asegúrate de que todos los pequeños detalles estén controlados -como que en el parámetro &lt;code&gt;baseURL&lt;/code&gt; se incluya la &lt;code&gt;/&lt;/code&gt; final- y te evitarás un montón de problemas.&lt;/p&gt;

&lt;p&gt;Si haces pruebas en un entorno de integración o consolidación, el único parámetro que hay que modificar al pasar a producción es la &lt;code&gt;baseURL&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para evitar confusiones, en esta entrada a la ruta al ejecutable de Hugo la llamo &lt;code&gt;$HUGO/hugo&lt;/code&gt;. El servidor web publica la web desde la carpeta &lt;code&gt;~/web&lt;/code&gt;. Supongo que la ruta a &lt;code&gt;hugo&lt;/code&gt; se encuentra en el &lt;code&gt;$PATH&lt;/code&gt; de tu equipo, por lo que puedes ejecutarlo lanzando &lt;code&gt;hugo&lt;/code&gt; sin necesidad de especificar la ruta al comando.&lt;/p&gt;

&lt;h2 id=&#34;crea-del-sitio&#34;&gt;Crea del sitio&lt;/h2&gt;

&lt;p&gt;El primer paso para crear un sitio con Hugo es crear una carpeta llamada y lanzar el comando &lt;code&gt;hugo new site&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir mi-sitio-web
$ cd mi-sitio-web
$ hugo new site mi-sitio-web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación, elige un tema (o crea el tuyo propio con &lt;code&gt;hugo new theme&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Configura los parámetros usados en el tema que hayas escogido en el fichero &lt;code&gt;$HUGO/config.toml&lt;/code&gt; y ¡listo!.&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/hugo-publicacion-01.png&#34; alt=&#34;Agregar nueva entrada con Hugo images/hugo-publicacion-01.png&#34; width=640 height=412 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;h2 id=&#34;crea-una-entrada&#34;&gt;Crea una entrada&lt;/h2&gt;

&lt;p&gt;Para crear una entrada, lanza el comando &lt;code&gt;hugo new post/nombre-entrada.md&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd mi-sitio-web
$ hugo new post/mi-primera-entrada.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta acción crea el fichero &lt;code&gt;$HUGO/content/post/nueva-entrada.md&lt;/code&gt;.&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/hugo-publicacion-02.png&#34; alt=&#34;Agregar nueva entrada con Hugo images/hugo-publicacion-02.png&#34; width=640 height=256 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;h2 id=&#34;edita-la-entrada&#34;&gt;Edita la entrada&lt;/h2&gt;

&lt;p&gt;Abre el fichero de la nueva entrada. Encontrarás algo como:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
title = &amp;quot;mi primera entrada&amp;quot;
thumbnail = &amp;quot;images/thumbnail.png&amp;quot;
categories = [&amp;quot;&amp;quot;]
tags = [&amp;quot;&amp;quot;]
date = &amp;quot;2017-04-01T22:36:46+02:00&amp;quot;

+++

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El contenido de cualquier entrada está compuesto por el &lt;em&gt;frontmatter&lt;/em&gt; (&lt;em&gt;metadata&lt;/em&gt; sobre la entrada) y el contenido de la entrada en sí: cualquier cosa a partir del bloque delimitado por &lt;code&gt;+++&lt;/code&gt;. El contenido &lt;em&gt;por defecto&lt;/em&gt; proviene del contenido de la carpeta &lt;code&gt;$HUGO/theme/{tema-usado}/archetypes/default.md&lt;/code&gt; (el contenido varía según el autor de cada tema).&lt;/p&gt;

&lt;p&gt;Al crear la entrada, además de la información copiada desde el &lt;em&gt;archetype&lt;/em&gt; Hugo añade siempre el título (por defecto, igual que el nombre del fichero) y la fecha.&lt;/p&gt;

&lt;p&gt;Ya puedes escribir tu entrada en cualquier editor de texto. Para dar formato al texto -negritas, cursivas-, crear enlaces, insertar imágenes, etc, se usa el &lt;a href=&#34;https://es.wikipedia.org/wiki/Markdown&#34;&gt;markdown&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para tener una idea de cómo va quedando la entrada, puedes usar &lt;code&gt;hugo server watch&lt;/code&gt;. Hugo incorpora un pequeño servidor web con el que puedes visualizar tu blog en modo &lt;em&gt;borrador&lt;/em&gt;, por llamarlo de algún modo. La opción &lt;code&gt;watch&lt;/code&gt; hace que Hugo regenere automáticamente el blog en cuanto detecte algún cambio. De esta manera puedes ir visualizando cómo queda la entrada antes de publicarla.&lt;/p&gt;

&lt;h2 id=&#34;publica-la-entrada&#34;&gt;Publica la entrada&lt;/h2&gt;

&lt;p&gt;Una vez que satisfecho con la entrada, hay que generar los ficheros que componen el blog.&lt;/p&gt;

&lt;p&gt;El blog es un conjunto de ficheros html, javascript y css en la carpeta &lt;code&gt;$HUGO/public&lt;/code&gt;. Para evitar que se mezclen ficheros de &amp;ldquo;publicaciones&amp;rdquo; anteriores, es recomendable borrar la carpeta antes de generar una nueva versión del blog.&lt;/p&gt;

&lt;p&gt;Para crear estos ficheros a partir de tus entradas y el tema que has escogido, simplemente lanza el comando &lt;code&gt;hugo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Hugo hace su magia y genera todos los ficheros necesarios, analizando el contenido de los ficheros. Estos ficheros se generan en la carpeta $HUGO/public`.&lt;/p&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/hugo-publicacion-03.png&#34; alt=&#34;Agregar nueva entrada con Hugo images/hugo-publicacion-03.png&#34; width=640 height=428 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;h2 id=&#34;sube-los-ficheros-al-servidor-web&#34;&gt;Sube los ficheros al servidor web&lt;/h2&gt;

&lt;p&gt;El siguiente paso es subir el contenido de la carpeta al servidor web.&lt;/p&gt;

&lt;p&gt;Para evitar que se mezclen los ficheros actuales y los nuevos, primero elimina el contenido de la carpeta del servidor.&lt;/p&gt;

&lt;p&gt;Mi servidor web es una Raspberry Pi B+, así que me conecto vía SSH y elimino el contenido de la carpeta &lt;code&gt;~/web&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ssh pirate@rpi.local
pirate@rpi.local: ~ $ cd web
pirate@rpi.local: ~/web $ rm -rf *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Después, copio el contendio de &lt;code&gt;$HUGO/public&lt;/code&gt; a &lt;code&gt;~/web&lt;/code&gt; en el servidor remoto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd $HUGO/public
$ scp -r * pirate@rpi.local:/home/pirate/web
&lt;/code&gt;&lt;/pre&gt;

&lt;figure&gt;
  &lt;amp-img src=&#34;https://onthedock.github.io/images/hugo-publicacion-04.png&#34; alt=&#34;Agregar nueva entrada con Hugo images/hugo-publicacion-04.png&#34; width=640 height=428 layout=&#34;responsive&#34;&gt;&lt;/amp-img&gt;
  
&lt;/figure&gt;


&lt;p&gt;Desde un navegador, comprueba que el blog se ha actualizado con la nueva entrada.&lt;/p&gt;

&lt;p&gt;Puedes descargar la referencia para todo el proceso: &lt;a href=&#34;../../images/hugo-publicacion-paso-a-paso.png&#34;&gt;Publicación en Hugo: Referencia&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>De Blogger a Hugo</title>
      <link>https://onthedock.github.io/post/de-blogger-a-hugo/</link>
      <pubDate>Sat, 01 Apr 2017 18:10:12 +0200</pubDate>
      
      <guid>https://onthedock.github.io/post/de-blogger-a-hugo/</guid>
      <description>&lt;p&gt;Porqué me estoy planteando dejar Blogger y pasar a un sitio estático gracias a Hugo.&lt;/p&gt;

&lt;p&gt;Hugo es un &lt;em&gt;generador de sitios estáticos&lt;/em&gt; a partir de ficheros en formato &lt;em&gt;markdown&lt;/em&gt;. Hugo aplica una plantilla al contenido de los ficheros en formato &lt;em&gt;markdon&lt;/em&gt; y crea los ficheros HTML.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;motivación&#34;&gt;Motivación&lt;/h2&gt;

&lt;p&gt;Aunque llevo &lt;em&gt;toda la vida&lt;/em&gt; con un blog personal en &lt;a href=&#34;https://www.blogger.com/&#34;&gt;Blogger&lt;/a&gt;, Google ha desatendido la plataforma y poco a poco se ha ido quedando atrás en prestaciones.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ghost.org&#34;&gt;Ghost&lt;/a&gt; es la platforma que cada vez más desarrolladores y escritores &lt;em&gt;técnicos&lt;/em&gt; usan, tanto en la versión alojada como en sus propias instalaciones. Es la que me gustaría usar para mis blogs: soporta &lt;em&gt;markdown&lt;/em&gt; y no se entromete en el proceso ni de escribir ni de publicar los artículos.&lt;/p&gt;

&lt;p&gt;Mi objetivo era ejecutar Ghost en la Raspberry Pi, pero al no existir soporte de SQLite para la arquitectura ARM, las imágenes para &lt;a href=&#34;https://github.com/alexellis/ghost-on-docker&#34;&gt;&lt;em&gt;contenedores&lt;/em&gt; Docker&lt;/a&gt; están desactualizadas y no siempre son fáciles de &lt;em&gt;construir&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por otro lado, el objetivo del blog en la Raspberry Pi es documentar el proceso de aprendizaje sobre  Docker y Kubernetes (además de Linux). A diferencia de lo que pasaba en mi anterior trabajo, donde estuve usando Hugo de forma &lt;em&gt;experimental&lt;/em&gt;, ahora estas notas no contienen ningún tipo de información privada, por lo que publicaré también los artículos en internet.&lt;/p&gt;

&lt;p&gt;En mis pruebas Hugo se integró en el flujo de trabajo diario sin interferir lo más mínimo, por lo que resultó una experiencia muy positiva.&lt;/p&gt;

&lt;p&gt;Quiero combinar este blog (orientado al avance, a las pruebas, es decir, al proceso) con Dokuwiki (como almacén de conocimiento y documentación). Sin embargo, con Dokuwiki la  &lt;em&gt;dualidad&lt;/em&gt; entre en entorno &lt;em&gt;local&lt;/em&gt; (en casa) y en internet es más difícil de conseguir de forma directa (usando recursos gratuitos). Tengo un &lt;a href=&#34;http://wiki-ameisin.rhcloud.com/&#34;&gt;contenedor en OpenShift&lt;/a&gt; con notas sobre diferentes temas, pero en esta instancia de Dokuwiki en OpenShift las carpetas de datos tienen una estructura diferente a la estándar, lo que dificulta mantener &lt;em&gt;sincronizadas&lt;/em&gt; la versión &lt;em&gt;local&lt;/em&gt; y la alojada en el &lt;em&gt;cloud&lt;/em&gt; de Red Hat.&lt;/p&gt;

&lt;h2 id=&#34;hugo&#34;&gt;Hugo&lt;/h2&gt;

&lt;p&gt;La idea detrás de un generador de sitios estáticos es que, en muchas ocasiones, no es necesario disponer de toda la potencia que ofrecen las plataformas de &lt;em&gt;blogging&lt;/em&gt; modernas como &lt;a href=&#34;https://wordpress.org&#34;&gt;Wordpress&lt;/a&gt;, etc. Además, estas plataformas no son siempre fáciles de instalar, configurar y mantener en tu propio entorno local.&lt;/p&gt;

&lt;p&gt;La alternativa es mantener un sitio web a partir de ficheros HTML independientes, pero resulta muy costoso en tiempo y esfuerzo.&lt;/p&gt;

&lt;p&gt;A medio camino se encuentran los generadores de sitios como &lt;a href=&#34;https://jekyllrb.com&#34;&gt;Jekill&lt;/a&gt; o &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Estos &lt;em&gt;generadores de sitios estáticos&lt;/em&gt; parten de ficheros en formato &lt;em&gt;markdown&lt;/em&gt; -que son sencillos de escribir- y se encargan de combinarlos con unas plantillas, generar los enlaces entre los diferentes artículos, crear nubes de etiquetas, etc (la parte tediosa) hasta generar los ficheros HTML.&lt;/p&gt;

&lt;p&gt;Al final del proceso, tenemos un conjunto de ficheros &lt;em&gt;web&lt;/em&gt; (HTML, javascript, css) que podemos alojar en cualquier servidor (o en servicios como &lt;a href=&#34;https://pages.github.com&#34;&gt;GitHub Pages&lt;/a&gt; o &lt;a href=&#34;https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html&#34;&gt;Bitbucket&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;siguientes-pasos&#34;&gt;Siguientes pasos&lt;/h2&gt;

&lt;p&gt;En estas fase inicial, únicamente tengo un contenedor con un servidor web (Nginx) sirviendo el sitio estático generado por Hugo (en un portátil).&lt;/p&gt;

&lt;p&gt;Más adelante quiero incluir también un contenedor con Hugo (como el proporcionado por &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-hugo/&#34;&gt;Hypriot&lt;/a&gt;) e ir añadiendo poco a poco todas las herramientas del proceso de Integración Continua -en forma de contenedores- desde el &lt;em&gt;código fuente&lt;/em&gt; al sitio web publicado automáticamente con cada cambio. Como se apunta en la entrada &lt;a href=&#34;https://blog.hypriot.com/post/static-website-generation-on-steriods-with-docker/&#34;&gt;Static Website Generation on Steriods with Docker&lt;/a&gt;, la idea es montar una cadena de &lt;a href=&#34;https://es.wikipedia.org/wiki/Integración_continua&#34;&gt;CI&lt;/a&gt;: GoGS (repositorio de código &lt;em&gt;a lo Github&lt;/em&gt;), &lt;a href=&#34;https://github.com/drone/drone&#34;&gt;Drone&lt;/a&gt; (el &lt;em&gt;motor&lt;/em&gt; de Integración Continua: como &lt;a href=&#34;https://es.wikipedia.org/wiki/Jenkins&#34;&gt;Jenkins&lt;/a&gt;, pero escrito en Go) y para el &lt;em&gt;deployment&lt;/em&gt;, una mezcla de &lt;a href=&#34;https://hub.docker.com/r/xaviaznar/rpi-alpine-nginx/&#34;&gt;Nginx&lt;/a&gt; (publicación local) y &lt;a href=&#34;https://bitbucket.org/product&#34;&gt;Bitbucket&lt;/a&gt; (publicación en internet).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Configura curl para usar un proxy</title>
      <link>https://onthedock.github.io/post/configura-curl-para-usar-proxy/</link>
      <pubDate>Wed, 11 Jan 2017 08:22:56 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/configura-curl-para-usar-proxy/</guid>
      <description>&lt;p&gt;Cómo configurar &lt;code&gt;curl&lt;/code&gt; para salir a internet a través de un &lt;em&gt;proxy&lt;/em&gt; que requiere autenticación.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Como la VM está detrás de un &lt;em&gt;proxy&lt;/em&gt;, primero tienes que indicar a &lt;code&gt;curl&lt;/code&gt; la dirección del mismo. La manera más sencilla de solucionar el problema de una vez por todas es indicar la URL del &lt;em&gt;proxy&lt;/em&gt; en el fichero &lt;code&gt;.curlrc&lt;/code&gt;, en la carpeta &lt;em&gt;home&lt;/em&gt; del usuario.&lt;/p&gt;

&lt;p&gt;Si estás trabajando con el usuario &lt;code&gt;root&lt;/code&gt;, coloca el fichero en &lt;code&gt;/root/.curlrc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Edita el fichero y añade la dirección del &lt;em&gt;proxy&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;proxy = https://${USERNAME}:${PASSWORD}@proxy.ameisin.com:8080/proxy.pac
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Referencia: &lt;a href=&#34;http://stackoverflow.com/questions/7559103/how-to-setup-curl-to-permanently-use-a-proxy&#34;&gt;How to setup curl to permanently use a proxy? [closed]&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Instala Docker en Ubuntu Server 16.04</title>
      <link>https://onthedock.github.io/post/instala-docker-en-ubuntu-server-16.04/</link>
      <pubDate>Tue, 10 Jan 2017 15:12:46 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/instala-docker-en-ubuntu-server-16.04/</guid>
      <description>&lt;p&gt;Cómo instalar Docker en Ubuntu Server 16.04.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Para instalar la última versión de Docker, usamos las instrucciones &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/como-instalar-y-usar-docker-en-ubuntu-16-04-es&#34;&gt;¿Cómo instalar y usar Docker en Ubuntu 16.04?&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;No funciona por algún motivo, probablemente por el &lt;em&gt;proxy&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Para instalar la clave GPG de Docker, el método que funciona es (&lt;small&gt;ref: &lt;a href=&#34;https://github.com/docker/docker/issues/17436#issuecomment-151870782&#34;&gt;Docker website encourages users to import GPG key for apt repository in unsafe ways #17436&lt;/a&gt;&lt;/small&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# curl -s  https://get.docker.com/gpg | apt-key add -
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agregamos el repositorio de Docker a APT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-add-repository &#39;deb https://apt.dockerproject.org/repo ubuntu-xenial main&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actualizamos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez añadido, comprobamos mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-cache policy docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finalmente, instalamos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install -y docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si ha habido problemas para validar la autenticidad del paquete de Docker, la instalación debe hacerse sin la aceptación automática (es decir, sin el parámetro &lt;code&gt;-y&lt;/code&gt;) o añadiendo &lt;code&gt;--allow-authenticate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Verificamos que tenemos docker funcionando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# docker version
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Configura el proxy para APT en Ubuntu Server 16.04</title>
      <link>https://onthedock.github.io/post/configura-apt-en-ubuntu-server-16.04/</link>
      <pubDate>Tue, 10 Jan 2017 15:01:55 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/configura-apt-en-ubuntu-server-16.04/</guid>
      <description>&lt;p&gt;Cómo configurar &lt;code&gt;apt&lt;/code&gt; para salir a internet a través de un &lt;em&gt;proxy&lt;/em&gt; que requiere autenticación.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;La configuración del &lt;em&gt;proxy&lt;/em&gt; para &lt;code&gt;APT&lt;/code&gt; en Ubuntu Server 16.04 se realiza a través del fichero &lt;code&gt;/etc/apt/apt.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Crea el fichero si no existe y escribe:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Acquire::http::Proxy &amp;quot;http://${USERNAME}:${PASSWORD}@proxy.ameisin.vwg:8080/amisin.pac&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación, ya puedes actualizar los repositorios usando &lt;code&gt;apt-get update&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introducción a Hypriot OS</title>
      <link>https://onthedock.github.io/post/introduccion-a-hypriotos/</link>
      <pubDate>Sat, 05 Nov 2016 10:37:47 +0100</pubDate>
      
      <guid>https://onthedock.github.io/post/introduccion-a-hypriotos/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blog.hypriot.com/about/#hypriotos:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;HypriotOS&lt;/a&gt; es un sistema operativo basado en &lt;a href=&#34;http://www.debian.org/&#34;&gt;Debian&lt;/a&gt; optimizado para ejecutar &lt;a href=&#34;http://www.docker.com/&#34;&gt;Docker&lt;/a&gt; en plataformas ARM como las &lt;a href=&#34;https://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;hypriotos&#34;&gt;HypriotOS&lt;/h1&gt;

&lt;p&gt;Las características principales de HypriotOs son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sistema operativo basado de Debian: la mayor parte de la gente saber cómo usar Debian y las distribuciones basadas en Ubuntu.&lt;/li&gt;
&lt;li&gt;Optimizado para Docker: Todo en HypriotOS está orientado a conseguir que Docker se ejecute de maravilla, desde las configuraciones del kernel de Linux hasta el sistema de ficheros.&lt;/li&gt;
&lt;li&gt;Versiones actualizadas de Docker: Hypriot se actualiza cada vez que se publica una nueva versión de Docker.&lt;/li&gt;
&lt;li&gt;Listo para usar: descargar, &lt;em&gt;flashear&lt;/em&gt; y arrancar, es lo único que hace falta para ponerse en marcha con HypriotOS.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;instalación-de-hypriotos&#34;&gt;Instalación de HypriotOS&lt;/h2&gt;

&lt;p&gt;La instalación de HypriotOS en la Raspberry Pi es muy sencilla.&lt;/p&gt;

&lt;p&gt;En el blog de Hypriot tienes información para grabar la imagen en una tarjeta SD tanto si usas &lt;a href=&#34;http://blog.hypriot.com/getting-started-with-docker-on-your-arm-device/&#34;&gt;Windows, Linux o Mac&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;En mi caso, he usado un equipo con Windows para pasar la imagen a la tarjeta SD siguiendo los siguientes pasos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Descarga la imagen con Hypriot en formato comprimido desde &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;sección de descargas del blog de Hypriot&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Descomprime el &lt;em&gt;zip&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Usa &lt;a href=&#34;http://sourceforge.net/projects/win32diskimager/&#34;&gt;Win32DiskImager&lt;/a&gt; para pasar la imagen descomprimida a la tarjeta SD.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;¡Eso es todo!&lt;/p&gt;

&lt;p&gt;El siguiente paso es colocar de nuevo la tarjeta SD en la Raspberry Pi y arrancar.&lt;/p&gt;

&lt;h2 id=&#34;obtener-la-dirección-ip-de-la-raspberry-pi&#34;&gt;Obtener la dirección IP de la Raspberry Pi&lt;/h2&gt;

&lt;p&gt;Por defecto, la Raspberry Pi con HypriotOS obtiene una dirección IP del DHCP local. En el blog de Hypriot recomiendan usar un programa para escanear tu red local y obtener la dirección asignada a la Raspberry Pi (&lt;a href=&#34;http://sourceforge.net/projects/nmap.mirror/?source=typ_redirect&#34;&gt;ZenMap&lt;/a&gt; o &lt;a href=&#34;http://angryip.org/download/#windows, en los comentarios&#34;&gt;Angry IP Scanner&lt;/a&gt;. En mi caso, he accedido a la lista de clientes a los cuales el DHCP les ha asignado una dirección IP y he obtenido la dirección asignada al equipo llamado &lt;em&gt;black-pearl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una vez obtenida la dirección IP, conéctate usando &lt;a href=&#34;http://the.earth.li/~sgtatham/putty/latest/x86/putty.exe&#34;&gt;&lt;em&gt;Putty&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Introduce la IP asignada a la Raspberry Pi en el campo &lt;em&gt;Host Name (or IP address)&lt;/em&gt; y verifica que el puerto es el 22.&lt;/p&gt;

&lt;p&gt;La primera vez que conectes a la dirección IP de la Raspberry Pi obtendrás un mensaje de aviso indicando si quieres confiar en el equipo.&lt;/p&gt;

&lt;p&gt;Puedes iniciar sesión en la Raspberry Pi usando el nombre de usuario &lt;code&gt;pirate&lt;/code&gt; y el password  &lt;code&gt;hypriot&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finalmente, para verificar que Docker se encuentra presente, ejecuta &lt;code&gt;docker info&lt;/code&gt;. La salida de este comando te devolverá las versiones de cliente y servidor instaladas.&lt;/p&gt;

&lt;h2 id=&#34;crea-tu-primer-contenedor&#34;&gt;Crea tu primer contenedor&lt;/h2&gt;

&lt;p&gt;Ya está todo listo para ejecutar tu primer contenedor. Y es tan sencillo como lanzar el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p 80:80 hypriot/rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este comando ejecuta un contendor (&lt;code&gt;docker run&lt;/code&gt;) en segundo plano, de forma no interactiva (&lt;code&gt;-d&lt;/code&gt;, &lt;em&gt;dettached&lt;/em&gt;), conectando el puerto 80 (web) de tu equipo local con el puerto 80 del contenedor. El contenedor se creará a partir de la imagen &lt;code&gt;hypriot/rpi-busybox-httpd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cuando Docker intenta crear el contenedor, busca la imagen indicada en su registro local. Si no lo encuentra, se conecta a un registro público -por defecto Docker Hub- y busca la imagen allí.&lt;/p&gt;

&lt;p&gt;Una vez localizada la imagen, descarga en el registro local una copia de la imagen y finalmente arranca un contenedor basado en esa imagen.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p  80:80 hypriot/rpi-busybox-httpd
Unable to find image &#39;hypriot/rpi-busybox-httpd:latest&#39; locally
latest: Pulling from hypriot/rpi-busybox-httpd
c74a9c6a645f: Pull complete
6f1938f6d8ae: Pull complete
e1347d4747a6: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:c00342f952d97628bf5dda457d3b409c37df687c859df82b9424f61264f54cd1
Status: Downloaded newer image for hypriot/rpi-busybox-httpd:latest
19d131999ea3142d44a83a6e943c9052d8defa43f7da372bd08ec441ee55f31b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La imagen descargada contiene &lt;code&gt;busybox&lt;/code&gt; y un servidor web minimalista. Puedes acceder al servidor arrancado en el contenedor a través de un navegador, indicando la IP de la Raspberry Pi.&lt;/p&gt;

&lt;h3 id=&#34;un-contenedor-más-útil&#34;&gt;Un contenedor más útil&lt;/h3&gt;

&lt;p&gt;Como ejemplo de primer contenedor y de lo fácil que es lanzar contenedores con Docker, el ejemplo anterior no está mal.&lt;/p&gt;

&lt;p&gt;Sin embargo, vamos a seguir los mismos pasos para crear un contenedor que proporciona un entorno web de gestión de Docker:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock hypriot/rpi-dockerui
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso observamos que, además de las instrucciones que hemos visto en el caso anterior, tenemos un nuevo parámetro &lt;code&gt;-v&lt;/code&gt;, que permite &lt;em&gt;montar&lt;/em&gt; una ruta local del equipo &lt;em&gt;host&lt;/em&gt; en el contenedor. Sin embargo, no te preocupes si ahora no entindes todos los detalles.&lt;/p&gt;

&lt;p&gt;Una vez arrancado el contenedor, accede a través de un navegador a &lt;code&gt;http://{IP-equipo-docker}:9000&lt;/code&gt;. Desde este entorno web puedes controlar el estado de tu instalación de Docker vía web gracias a &lt;a href=&#34;https://github.com/kevana/ui-for-docker&#34;&gt;UI-for-Docker&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;asigna-una-ip-estática&#34;&gt;Asigna una IP estática&lt;/h2&gt;

&lt;p&gt;En el apartado anterior hemos visto cómo instalar Docker y hemos lanzado los primeros contenedores. Pero la Raspberry Pi sigue con la configuración de la dirección IP dinámica, por lo que puede que la próxima vez que intentes acceder a la RPi, su dirección haya cambiado.&lt;/p&gt;

&lt;p&gt;Para evitar estos problemas, vamos a asignar la IP -estática- 192.168.1.51.&lt;/p&gt;

&lt;p&gt;Abrimos el fichero &lt;code&gt;/etc/network/interfaces&lt;/code&gt; y encontramos que se hace referencia a una carpeta de configuración:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;# interfaces(5) file used by ifup(8) and ifdown(8)
# Include files from /etc/network/interfaces.d:
source-directory /etc/network/interfaces.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abrimos el fichero de configuración de la tarjeta de red &lt;code&gt;eth0&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;allow-hotplug eth0
iface eth0 inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vemos que está configurada en modo &lt;code&gt;DHCP&lt;/code&gt;, por lo que comentamos la segunda línea y especificamos la configuración de IP estática:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;# iface eth0 inet dhcp

# Set static IP 
iface eth0 inet static
address 192.168.1.51
gateway 192.168.1.1
domain_name_servers=8.8.8.8, 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por supuesto, debes indicar la configuración de red de tu entorno.&lt;/p&gt;

&lt;p&gt;Guardamos los cambios y reiniciamos el servicio de red mediante:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo $ sudo /etc/init.d/networking restart
[....] Restarting networking (via systemctl): networking.service
. ok
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Como la IP de la Raspberry Pi ha cambiado, la conexión remota desde tu equipo se perderá.&lt;/p&gt;

&lt;p&gt;Debes conectar de nuevo con la Raspberry Pi usando la IP que acabas de asignar.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;encontrando-tu-raspberry-pi-en-la-red-gracias-a-avahi&#34;&gt;Encontrando tu Raspberry Pi en la red gracias a Avahi&lt;/h3&gt;

&lt;p&gt;Desde la versión 0.3 &lt;em&gt;Jack&lt;/em&gt;, HypriotOS usa &lt;a href=&#34;https://en.wikipedia.org/wiki/Avahi_(software)&#34;&gt;Avahi&lt;/a&gt;, el sistema que permite a los programas publicar y descubrir servicios y hosts en una red local. De esta forma puedes acceder a los servicios publicados por los contenedores vía web (o hacer un ping) usando el nombre del sistema: &lt;strong&gt;&lt;code&gt;black-pearl&lt;/code&gt;&lt;/strong&gt; (por defecto).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;He comprobado que funciona desde un equipo Mac; falta comprobarlo desde un equipo Windows.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>